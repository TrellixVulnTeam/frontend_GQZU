import { animationFrameScheduler, fromEvent, interval, NEVER } from 'rxjs';
import { distinctUntilChanged, map, switchMap, tap } from 'rxjs/operators';
import { ktdNormalizePassiveListenerOptions } from './passive-listeners';
import { getMutableClientRect } from './client-rect';
import { ktdNoEmit } from './operators';
/**
 * Proximity, as a ratio to width/height at which to start auto-scrolling.
 * The value comes from trying it out manually until it feels right.
 */
const SCROLL_PROXIMITY_THRESHOLD = 0.05;
/**
 * Increments the vertical scroll position of a node.
 * @param node Node whose scroll position should change.
 * @param amount Amount of pixels that the `node` should be scrolled.
 */
function incrementVerticalScroll(node, amount) {
    if (node === window) {
        node.scrollBy(0, amount);
    }
    else {
        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.
        node.scrollTop += amount;
    }
}
/**
 * Increments the horizontal scroll position of a node.
 * @param node Node whose scroll position should change.
 * @param amount Amount of pixels that the `node` should be scrolled.
 */
function incrementHorizontalScroll(node, amount) {
    if (node === window) {
        node.scrollBy(amount, 0);
    }
    else {
        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.
        node.scrollLeft += amount;
    }
}
/**
 * Gets whether the vertical auto-scroll direction of a node.
 * @param clientRect Dimensions of the node.
 * @param pointerY Position of the user's pointer along the y axis.
 */
function getVerticalScrollDirection(clientRect, pointerY) {
    const { top, bottom, height } = clientRect;
    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
        return 1 /* UP */;
    }
    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
        return 2 /* DOWN */;
    }
    return 0 /* NONE */;
}
/**
 * Gets whether the horizontal auto-scroll direction of a node.
 * @param clientRect Dimensions of the node.
 * @param pointerX Position of the user's pointer along the x axis.
 */
function getHorizontalScrollDirection(clientRect, pointerX) {
    const { left, right, width } = clientRect;
    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
        return 1 /* LEFT */;
    }
    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
        return 2 /* RIGHT */;
    }
    return 0 /* NONE */;
}
/**
 * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.
 * This observable doesn't emit, it just performs the 'scroll' side effect.
 * @param scrollNode, node where the scroll would be applied.
 * @param verticalScrollDirection, vertical direction of the scroll.
 * @param horizontalScrollDirection, horizontal direction of the scroll.
 * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.
 */
function scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, scrollStep = 2) {
    return interval(0, animationFrameScheduler)
        .pipe(tap(() => {
        if (verticalScrollDirection === 1 /* UP */) {
            incrementVerticalScroll(scrollNode, -scrollStep);
        }
        else if (verticalScrollDirection === 2 /* DOWN */) {
            incrementVerticalScroll(scrollNode, scrollStep);
        }
        if (horizontalScrollDirection === 1 /* LEFT */) {
            incrementHorizontalScroll(scrollNode, -scrollStep);
        }
        else if (horizontalScrollDirection === 2 /* RIGHT */) {
            incrementHorizontalScroll(scrollNode, scrollStep);
        }
    }), ktdNoEmit());
}
/**
 * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.
 * This observable doesn't emit, it just performs a 'scroll' side effect.
 * @param scrollableParent, parent node in which the scroll would be performed.
 * @param options, configuration options.
 */
export function ktdScrollIfNearElementClientRect$(scrollableParent, options) {
    let scrollNode;
    let scrollableParentClientRect;
    let scrollableParentScrollWidth;
    if (scrollableParent === document) {
        scrollNode = document.defaultView;
        const { width, height } = getViewportSize();
        scrollableParentClientRect = { width, height, top: 0, right: width, bottom: height, left: 0 };
        scrollableParentScrollWidth = getDocumentScrollWidth();
    }
    else {
        scrollNode = scrollableParent;
        scrollableParentClientRect = getMutableClientRect(scrollableParent);
        scrollableParentScrollWidth = scrollableParent.scrollWidth;
    }
    /**
     * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.
     * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this
     * specific use case.
     */
    options = options || {};
    if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {
        options.disableHorizontal = true;
    }
    return (source$) => source$.pipe(map(({ pointerX, pointerY }) => {
        let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);
        let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX);
        // Check if scroll directions are disabled.
        if (options === null || options === void 0 ? void 0 : options.disableVertical) {
            verticalScrollDirection = 0 /* NONE */;
        }
        if (options === null || options === void 0 ? void 0 : options.disableHorizontal) {
            horizontalScrollDirection = 0 /* NONE */;
        }
        return { verticalScrollDirection, horizontalScrollDirection };
    }), distinctUntilChanged((prev, actual) => {
        return prev.verticalScrollDirection === actual.verticalScrollDirection
            && prev.horizontalScrollDirection === actual.horizontalScrollDirection;
    }), switchMap(({ verticalScrollDirection, horizontalScrollDirection }) => {
        if (verticalScrollDirection || horizontalScrollDirection) {
            return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options === null || options === void 0 ? void 0 : options.scrollStep);
        }
        else {
            return NEVER;
        }
    }));
}
/**
 * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.
 * @param scrollableParent, node in which scroll events would be listened.
 */
export function ktdGetScrollTotalRelativeDifference$(scrollableParent) {
    let scrollInitialPosition;
    // Calculate initial scroll position
    if (scrollableParent === document) {
        scrollInitialPosition = getViewportScrollPosition();
    }
    else {
        scrollInitialPosition = {
            top: scrollableParent.scrollTop,
            left: scrollableParent.scrollLeft
        };
    }
    return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({ capture: true })).pipe(map(() => {
        let newTop;
        let newLeft;
        if (scrollableParent === document) {
            const viewportScrollPosition = getViewportScrollPosition();
            newTop = viewportScrollPosition.top;
            newLeft = viewportScrollPosition.left;
        }
        else {
            newTop = scrollableParent.scrollTop;
            newLeft = scrollableParent.scrollLeft;
        }
        const topDifference = scrollInitialPosition.top - newTop;
        const leftDifference = scrollInitialPosition.left - newLeft;
        return { top: topDifference, left: leftDifference };
    }));
}
/** Returns the viewport's width and height. */
function getViewportSize() {
    const _window = document.defaultView || window;
    return {
        width: _window.innerWidth,
        height: _window.innerHeight
    };
}
/** Gets a ClientRect for the viewport's bounds. */
function getViewportRect() {
    // Use the document element's bounding rect rather than the window scroll properties
    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll
    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different
    // conceptual viewports. Under most circumstances these viewports are equivalent, but they
    // can disagree when the page is pinch-zoomed (on devices that support touch).
    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4
    // We use the documentElement instead of the body because, by default (without a css reset)
    // browsers typically give the document body an 8px margin, which is not included in
    // getBoundingClientRect().
    const scrollPosition = getViewportScrollPosition();
    const { width, height } = getViewportSize();
    return {
        top: scrollPosition.top,
        left: scrollPosition.left,
        bottom: scrollPosition.top + height,
        right: scrollPosition.left + width,
        height,
        width,
    };
}
/** Gets the (top, left) scroll position of the viewport. */
function getViewportScrollPosition() {
    // The top-left-corner of the viewport is determined by the scroll position of the document
    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about
    // whether `document.body` or `document.documentElement` is the scrolled element, so reading
    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of
    // `document.documentElement` works consistently, where the `top` and `left` values will
    // equal negative the scroll position.
    const windowRef = document.defaultView || window;
    const documentElement = document.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY ||
        documentElement.scrollTop || 0;
    const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX ||
        documentElement.scrollLeft || 0;
    return { top, left };
}
/** Returns the document scroll width */
function getDocumentScrollWidth() {
    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1ncmlkLWxheW91dC9zcmMvbGliL3V0aWxzL3Njcm9sbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDdkYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0UsT0FBTyxFQUFFLGtDQUFrQyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDekUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFeEM7OztHQUdHO0FBQ0gsTUFBTSwwQkFBMEIsR0FBRyxJQUFJLENBQUM7QUFjeEM7Ozs7R0FJRztBQUNILFNBQVMsdUJBQXVCLENBQUMsSUFBMEIsRUFBRSxNQUFjO0lBQ3ZFLElBQUksSUFBSSxLQUFLLE1BQU0sRUFBRTtRQUNoQixJQUFlLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUN4QztTQUFNO1FBQ0gsMEZBQTBGO1FBQ3pGLElBQW9CLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQztLQUM3QztBQUNMLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyx5QkFBeUIsQ0FBQyxJQUEwQixFQUFFLE1BQWM7SUFDekUsSUFBSSxJQUFJLEtBQUssTUFBTSxFQUFFO1FBQ2hCLElBQWUsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ3hDO1NBQU07UUFDSCwwRkFBMEY7UUFDekYsSUFBb0IsQ0FBQyxVQUFVLElBQUksTUFBTSxDQUFDO0tBQzlDO0FBQ0wsQ0FBQztBQUdEOzs7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TUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLGVBQWdCLENBQUM7SUFDbEQsTUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFFN0QsTUFBTSxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxPQUFPO1FBQ3pFLGVBQWUsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDO0lBRW5DLE1BQU0sSUFBSSxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxTQUFTLENBQUMsT0FBTztRQUM1RSxlQUFlLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQztJQUVwQyxPQUFPLEVBQUMsR0FBRyxFQUFFLElBQUksRUFBQyxDQUFDO0FBQ3ZCLENBQUM7QUFFRCx3Q0FBd0M7QUFDeEMsU0FBUyxzQkFBc0I7SUFDM0IsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDckYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLCBmcm9tRXZlbnQsIGludGVydmFsLCBORVZFUiwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCBzd2l0Y2hNYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsga3RkTm9ybWFsaXplUGFzc2l2ZUxpc3RlbmVyT3B0aW9ucyB9IGZyb20gJy4vcGFzc2l2ZS1saXN0ZW5lcnMnO1xyXG5pbXBvcnQgeyBnZXRNdXRhYmxlQ2xpZW50UmVjdCB9IGZyb20gJy4vY2xpZW50LXJlY3QnO1xyXG5pbXBvcnQgeyBrdGROb0VtaXQgfSBmcm9tICcuL29wZXJhdG9ycyc7XHJcblxyXG4vKipcclxuICogUHJveGltaXR5LCBhcyBhIHJhdGlvIHRvIHdpZHRoL2hlaWdodCBhdCB3aGljaCB0byBzdGFydCBhdXRvLXNjcm9sbGluZy5cclxuICogVGhlIHZhbHVlIGNvbWVzIGZyb20gdHJ5aW5nIGl0IG91dCBtYW51YWxseSB1bnRpbCBpdCBmZWVscyByaWdodC5cclxuICovXHJcbmNvbnN0IFNDUk9MTF9QUk9YSU1JVFlfVEhSRVNIT0xEID0gMC4wNTtcclxuXHJcbi8qKiBWZXJ0aWNhbCBkaXJlY3Rpb24gaW4gd2hpY2ggd2UgY2FuIGF1dG8tc2Nyb2xsLiAqL1xyXG5jb25zdCBlbnVtIEF1dG9TY3JvbGxWZXJ0aWNhbERpcmVjdGlvbiB7Tk9ORSwgVVAsIERPV059XHJcblxyXG4vKiogSG9yaXpvbnRhbCBkaXJlY3Rpb24gaW4gd2hpY2ggd2UgY2FuIGF1dG8tc2Nyb2xsLiAqL1xyXG5jb25zdCBlbnVtIEF1dG9TY3JvbGxIb3Jpem9udGFsRGlyZWN0aW9uIHtOT05FLCBMRUZULCBSSUdIVH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgS3RkU2Nyb2xsUG9zaXRpb24ge1xyXG4gICAgdG9wOiBudW1iZXI7XHJcbiAgICBsZWZ0OiBudW1iZXI7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogSW5jcmVtZW50cyB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uIG9mIGEgbm9kZS5cclxuICogQHBhcmFtIG5vZGUgTm9kZSB3aG9zZSBzY3JvbGwgcG9zaXRpb24gc2hvdWxkIGNoYW5nZS5cclxuICogQHBhcmFtIGFtb3VudCBBbW91bnQgb2YgcGl4ZWxzIHRoYXQgdGhlIGBub2RlYCBzaG91bGQgYmUgc2Nyb2xsZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmNyZW1lbnRWZXJ0aWNhbFNjcm9sbChub2RlOiBIVE1MRWxlbWVudCB8IFdpbmRvdywgYW1vdW50OiBudW1iZXIpIHtcclxuICAgIGlmIChub2RlID09PSB3aW5kb3cpIHtcclxuICAgICAgICAobm9kZSBhcyBXaW5kb3cpLnNjcm9sbEJ5KDAsIGFtb3VudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIElkZWFsbHkgd2UgY291bGQgdXNlIGBFbGVtZW50LnNjcm9sbEJ5YCBoZXJlIGFzIHdlbGwsIGJ1dCBJRSBhbmQgRWRnZSBkb24ndCBzdXBwb3J0IGl0LlxyXG4gICAgICAgIChub2RlIGFzIEhUTUxFbGVtZW50KS5zY3JvbGxUb3AgKz0gYW1vdW50O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW5jcmVtZW50cyB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24gb2YgYSBub2RlLlxyXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHdob3NlIHNjcm9sbCBwb3NpdGlvbiBzaG91bGQgY2hhbmdlLlxyXG4gKiBAcGFyYW0gYW1vdW50IEFtb3VudCBvZiBwaXhlbHMgdGhhdCB0aGUgYG5vZGVgIHNob3VsZCBiZSBzY3JvbGxlZC5cclxuICovXHJcbmZ1bmN0aW9uIGluY3JlbWVudEhvcml6b250YWxTY3JvbGwobm9kZTogSFRNTEVsZW1lbnQgfCBXaW5kb3csIGFtb3VudDogbnVtYmVyKSB7XHJcbiAgICBpZiAobm9kZSA9PT0gd2luZG93KSB7XHJcbiAgICAgICAgKG5vZGUgYXMgV2luZG93KS5zY3JvbGxCeShhbW91bnQsIDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZGVhbGx5IHdlIGNvdWxkIHVzZSBgRWxlbWVudC5zY3JvbGxCeWAgaGVyZSBhcyB3ZWxsLCBidXQgSUUgYW5kIEVkZ2UgZG9uJ3Qgc3VwcG9ydCBpdC5cclxuICAgICAgICAobm9kZSBhcyBIVE1MRWxlbWVudCkuc2Nyb2xsTGVmdCArPSBhbW91bnQ7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2V0cyB3aGV0aGVyIHRoZSB2ZXJ0aWNhbCBhdXRvLXNjcm9sbCBkaXJlY3Rpb24gb2YgYSBub2RlLlxyXG4gKiBAcGFyYW0gY2xpZW50UmVjdCBEaW1lbnNpb25zIG9mIHRoZSBub2RlLlxyXG4gKiBAcGFyYW0gcG9pbnRlclkgUG9zaXRpb24gb2YgdGhlIHVzZXIncyBwb2ludGVyIGFsb25nIHRoZSB5IGF4aXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbFNjcm9sbERpcmVjdGlvbihjbGllbnRSZWN0OiBDbGllbnRSZWN0LCBwb2ludGVyWTogbnVtYmVyKSB7XHJcbiAgICBjb25zdCB7dG9wLCBib3R0b20sIGhlaWdodH0gPSBjbGllbnRSZWN0O1xyXG4gICAgY29uc3QgeVRocmVzaG9sZCA9IGhlaWdodCAqIFNDUk9MTF9QUk9YSU1JVFlfVEhSRVNIT0xEO1xyXG5cclxuICAgIGlmIChwb2ludGVyWSA+PSB0b3AgLSB5VGhyZXNob2xkICYmIHBvaW50ZXJZIDw9IHRvcCArIHlUaHJlc2hvbGQpIHtcclxuICAgICAgICByZXR1cm4gQXV0b1Njcm9sbFZlcnRpY2FsRGlyZWN0aW9uLlVQO1xyXG4gICAgfSBlbHNlIGlmIChwb2ludGVyWSA+PSBib3R0b20gLSB5VGhyZXNob2xkICYmIHBvaW50ZXJZIDw9IGJvdHRvbSArIHlUaHJlc2hvbGQpIHtcclxuICAgICAgICByZXR1cm4gQXV0b1Njcm9sbFZlcnRpY2FsRGlyZWN0aW9uLkRPV047XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEF1dG9TY3JvbGxWZXJ0aWNhbERpcmVjdGlvbi5OT05FO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB3aGV0aGVyIHRoZSBob3Jpem9udGFsIGF1dG8tc2Nyb2xsIGRpcmVjdGlvbiBvZiBhIG5vZGUuXHJcbiAqIEBwYXJhbSBjbGllbnRSZWN0IERpbWVuc2lvbnMgb2YgdGhlIG5vZGUuXHJcbiAqIEBwYXJhbSBwb2ludGVyWCBQb3NpdGlvbiBvZiB0aGUgdXNlcidzIHBvaW50ZXIgYWxvbmcgdGhlIHggYXhpcy5cclxuICovXHJcbmZ1bmN0aW9uIGdldEhvcml6b250YWxTY3JvbGxEaXJlY3Rpb24oY2xpZW50UmVjdDogQ2xpZW50UmVjdCwgcG9pbnRlclg6IG51bWJlcikge1xyXG4gICAgY29uc3Qge2xlZnQsIHJpZ2h0LCB3aWR0aH0gPSBjbGllbnRSZWN0O1xyXG4gICAgY29uc3QgeFRocmVzaG9sZCA9IHdpZHRoICogU0NST0xMX1BST1hJTUlUWV9USFJFU0hPTEQ7XHJcblxyXG4gICAgaWYgKHBvaW50ZXJYID49IGxlZnQgLSB4VGhyZXNob2xkICYmIHBvaW50ZXJYIDw9IGxlZnQgKyB4VGhyZXNob2xkKSB7XHJcbiAgICAgICAgcmV0dXJuIEF1dG9TY3JvbGxIb3Jpem9udGFsRGlyZWN0aW9uLkxFRlQ7XHJcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJYID49IHJpZ2h0IC0geFRocmVzaG9sZCAmJiBwb2ludGVyWCA8PSByaWdodCArIHhUaHJlc2hvbGQpIHtcclxuICAgICAgICByZXR1cm4gQXV0b1Njcm9sbEhvcml6b250YWxEaXJlY3Rpb24uUklHSFQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEF1dG9TY3JvbGxIb3Jpem9udGFsRGlyZWN0aW9uLk5PTkU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBzY2hlZHVsZXMgYSBsb29wIGFuZCBhcHBseSBzY3JvbGwgb24gdGhlIHNjcm9sbE5vZGUgaW50byB0aGUgc3BlY2lmaWVkIGRpcmVjdGlvbi9zLlxyXG4gKiBUaGlzIG9ic2VydmFibGUgZG9lc24ndCBlbWl0LCBpdCBqdXN0IHBlcmZvcm1zIHRoZSAnc2Nyb2xsJyBzaWRlIGVmZmVjdC5cclxuICogQHBhcmFtIHNjcm9sbE5vZGUsIG5vZGUgd2hlcmUgdGhlIHNjcm9sbCB3b3VsZCBiZSBhcHBsaWVkLlxyXG4gKiBAcGFyYW0gdmVydGljYWxTY3JvbGxEaXJlY3Rpb24sIHZlcnRpY2FsIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsLlxyXG4gKiBAcGFyYW0gaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiwgaG9yaXpvbnRhbCBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbC5cclxuICogQHBhcmFtIHNjcm9sbFN0ZXAsIHNjcm9sbCBzdGVwIGluIENTUyBwaXhlbHMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIGluIGV2ZXJ5IGxvb3AuXHJcbiAqL1xyXG5mdW5jdGlvbiBzY3JvbGxUb0RpcmVjdGlvbkludGVydmFsJChzY3JvbGxOb2RlOiBIVE1MRWxlbWVudCB8IFdpbmRvdywgdmVydGljYWxTY3JvbGxEaXJlY3Rpb246IEF1dG9TY3JvbGxWZXJ0aWNhbERpcmVjdGlvbiwgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbjogQXV0b1Njcm9sbEhvcml6b250YWxEaXJlY3Rpb24sIHNjcm9sbFN0ZXA6IG51bWJlciA9IDIpIHtcclxuICAgIHJldHVybiBpbnRlcnZhbCgwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlcilcclxuICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgdGFwKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiA9PT0gQXV0b1Njcm9sbFZlcnRpY2FsRGlyZWN0aW9uLlVQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50VmVydGljYWxTY3JvbGwoc2Nyb2xsTm9kZSwgLXNjcm9sbFN0ZXApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiA9PT0gQXV0b1Njcm9sbFZlcnRpY2FsRGlyZWN0aW9uLkRPV04pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRWZXJ0aWNhbFNjcm9sbChzY3JvbGxOb2RlLCBzY3JvbGxTdGVwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiA9PT0gQXV0b1Njcm9sbEhvcml6b250YWxEaXJlY3Rpb24uTEVGVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEhvcml6b250YWxTY3JvbGwoc2Nyb2xsTm9kZSwgLXNjcm9sbFN0ZXApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uID09PSBBdXRvU2Nyb2xsSG9yaXpvbnRhbERpcmVjdGlvbi5SSUdIVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEhvcml6b250YWxTY3JvbGwoc2Nyb2xsTm9kZSwgc2Nyb2xsU3RlcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBrdGROb0VtaXQoKVxyXG4gICAgICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgS3RkU2Nyb2xsSWZOZWFyRWxlbWVudE9wdGlvbnMge1xyXG4gICAgc2Nyb2xsU3RlcD86IG51bWJlcjtcclxuICAgIGRpc2FibGVWZXJ0aWNhbD86IGJvb2xlYW47XHJcbiAgICBkaXNhYmxlSG9yaXpvbnRhbD86IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIHNvdXJjZSQgb2JzZXJ2YWJsZSB3aXRoIHBvaW50ZXIgbG9jYXRpb24sIHNjcm9sbCB0aGUgc2Nyb2xsTm9kZSBpZiB0aGUgcG9pbnRlciBpcyBuZWFyIHRvIGl0LlxyXG4gKiBUaGlzIG9ic2VydmFibGUgZG9lc24ndCBlbWl0LCBpdCBqdXN0IHBlcmZvcm1zIGEgJ3Njcm9sbCcgc2lkZSBlZmZlY3QuXHJcbiAqIEBwYXJhbSBzY3JvbGxhYmxlUGFyZW50LCBwYXJlbnQgbm9kZSBpbiB3aGljaCB0aGUgc2Nyb2xsIHdvdWxkIGJlIHBlcmZvcm1lZC5cclxuICogQHBhcmFtIG9wdGlvbnMsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBrdGRTY3JvbGxJZk5lYXJFbGVtZW50Q2xpZW50UmVjdCQoc2Nyb2xsYWJsZVBhcmVudDogSFRNTEVsZW1lbnQgfCBEb2N1bWVudCwgb3B0aW9ucz86IEt0ZFNjcm9sbElmTmVhckVsZW1lbnRPcHRpb25zKTogKHNvdXJjZSQ6IE9ic2VydmFibGU8eyBwb2ludGVyWDogbnVtYmVyLCBwb2ludGVyWTogbnVtYmVyIH0+KSA9PiBPYnNlcnZhYmxlPGFueT4ge1xyXG5cclxuICAgIGxldCBzY3JvbGxOb2RlOiBXaW5kb3cgfCBIVE1MRWxlbWVudDtcclxuICAgIGxldCBzY3JvbGxhYmxlUGFyZW50Q2xpZW50UmVjdDogQ2xpZW50UmVjdDtcclxuICAgIGxldCBzY3JvbGxhYmxlUGFyZW50U2Nyb2xsV2lkdGg6IG51bWJlcjtcclxuXHJcbiAgICBpZiAoc2Nyb2xsYWJsZVBhcmVudCA9PT0gZG9jdW1lbnQpIHtcclxuICAgICAgICBzY3JvbGxOb2RlID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgYXMgV2luZG93O1xyXG4gICAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGdldFZpZXdwb3J0U2l6ZSgpO1xyXG4gICAgICAgIHNjcm9sbGFibGVQYXJlbnRDbGllbnRSZWN0ID0ge3dpZHRoLCBoZWlnaHQsIHRvcDogMCwgcmlnaHQ6IHdpZHRoLCBib3R0b206IGhlaWdodCwgbGVmdDogMH07XHJcbiAgICAgICAgc2Nyb2xsYWJsZVBhcmVudFNjcm9sbFdpZHRoID0gZ2V0RG9jdW1lbnRTY3JvbGxXaWR0aCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzY3JvbGxOb2RlID0gc2Nyb2xsYWJsZVBhcmVudCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBzY3JvbGxhYmxlUGFyZW50Q2xpZW50UmVjdCA9IGdldE11dGFibGVDbGllbnRSZWN0KHNjcm9sbGFibGVQYXJlbnQgYXMgSFRNTEVsZW1lbnQpO1xyXG4gICAgICAgIHNjcm9sbGFibGVQYXJlbnRTY3JvbGxXaWR0aCA9IChzY3JvbGxhYmxlUGFyZW50IGFzIEhUTUxFbGVtZW50KS5zY3JvbGxXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElNUE9SVEFOVDogQnkgZGVzaWduLCBvbmx5IGxldCBzY3JvbGwgaG9yaXpvbnRhbCBpZiB0aGUgc2Nyb2xsYWJsZSBwYXJlbnQgaGFzIGV4cGxpY2l0bHkgYW4gc2Nyb2xsIGhvcml6b250YWwuXHJcbiAgICAgKiBUaGlzIGxheW91dCBzb2x1dGlvbiBpcyBub3QgZGVzaWduZWQgaW4gbWluZCB0byBoYXZlIGFueSBzY3JvbGwgaG9yaXpvbnRhbCwgYnV0IGV4Y2VwdGlvbmFsbHkgd2UgYWxsb3cgaXQgaW4gdGhpc1xyXG4gICAgICogc3BlY2lmaWMgdXNlIGNhc2UuXHJcbiAgICAgKi9cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgaWYgKG9wdGlvbnMuZGlzYWJsZUhvcml6b250YWwgPT0gbnVsbCAmJiBzY3JvbGxhYmxlUGFyZW50U2Nyb2xsV2lkdGggPD0gc2Nyb2xsYWJsZVBhcmVudENsaWVudFJlY3Qud2lkdGgpIHtcclxuICAgICAgICBvcHRpb25zLmRpc2FibGVIb3Jpem9udGFsID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHNvdXJjZSQpID0+IHNvdXJjZSQucGlwZShcclxuICAgICAgICBtYXAoKHtwb2ludGVyWCwgcG9pbnRlcll9KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiA9IGdldFZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uKHNjcm9sbGFibGVQYXJlbnRDbGllbnRSZWN0LCBwb2ludGVyWSk7XHJcbiAgICAgICAgICAgIGxldCBob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uID0gZ2V0SG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbihzY3JvbGxhYmxlUGFyZW50Q2xpZW50UmVjdCwgcG9pbnRlclgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc2Nyb2xsIGRpcmVjdGlvbnMgYXJlIGRpc2FibGVkLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucz8uZGlzYWJsZVZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiA9IEF1dG9TY3JvbGxWZXJ0aWNhbERpcmVjdGlvbi5OT05FO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5kaXNhYmxlSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiA9IEF1dG9TY3JvbGxIb3Jpem9udGFsRGlyZWN0aW9uLk5PTkU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7dmVydGljYWxTY3JvbGxEaXJlY3Rpb24sIGhvcml6b250YWxTY3JvbGxEaXJlY3Rpb259O1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKChwcmV2LCBhY3R1YWwpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXYudmVydGljYWxTY3JvbGxEaXJlY3Rpb24gPT09IGFjdHVhbC52ZXJ0aWNhbFNjcm9sbERpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgJiYgcHJldi5ob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uID09PSBhY3R1YWwuaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbjtcclxuICAgICAgICB9KSxcclxuICAgICAgICBzd2l0Y2hNYXAoKHt2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiwgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbn0pID0+IHtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uIHx8IGhvcml6b250YWxTY3JvbGxEaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY3JvbGxUb0RpcmVjdGlvbkludGVydmFsJChzY3JvbGxOb2RlLCB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiwgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiwgb3B0aW9ucz8uc2Nyb2xsU3RlcCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTkVWRVI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVtaXRzIG9uIEVWRVJZIHNjcm9sbCBldmVudCBhbmQgcmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgc2Nyb2xsIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaW5pdGlhbCBzY3JvbGwgcG9zaXRpb24uXHJcbiAqIEBwYXJhbSBzY3JvbGxhYmxlUGFyZW50LCBub2RlIGluIHdoaWNoIHNjcm9sbCBldmVudHMgd291bGQgYmUgbGlzdGVuZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24ga3RkR2V0U2Nyb2xsVG90YWxSZWxhdGl2ZURpZmZlcmVuY2UkKHNjcm9sbGFibGVQYXJlbnQ6IEhUTUxFbGVtZW50IHwgRG9jdW1lbnQpOiBPYnNlcnZhYmxlPHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9PiB7XHJcbiAgICBsZXQgc2Nyb2xsSW5pdGlhbFBvc2l0aW9uO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBpbml0aWFsIHNjcm9sbCBwb3NpdGlvblxyXG4gICAgaWYgKHNjcm9sbGFibGVQYXJlbnQgPT09IGRvY3VtZW50KSB7XHJcbiAgICAgICAgc2Nyb2xsSW5pdGlhbFBvc2l0aW9uID0gZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzY3JvbGxJbml0aWFsUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHRvcDogKHNjcm9sbGFibGVQYXJlbnQgYXMgSFRNTEVsZW1lbnQpLnNjcm9sbFRvcCxcclxuICAgICAgICAgICAgbGVmdDogKHNjcm9sbGFibGVQYXJlbnQgYXMgSFRNTEVsZW1lbnQpLnNjcm9sbExlZnRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmcm9tRXZlbnQoc2Nyb2xsYWJsZVBhcmVudCwgJ3Njcm9sbCcsIGt0ZE5vcm1hbGl6ZVBhc3NpdmVMaXN0ZW5lck9wdGlvbnMoe2NhcHR1cmU6IHRydWV9KSBhcyBBZGRFdmVudExpc3RlbmVyT3B0aW9ucykucGlwZShcclxuICAgICAgICBtYXAoKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmV3VG9wOiBudW1iZXI7XHJcbiAgICAgICAgICAgIGxldCBuZXdMZWZ0OiBudW1iZXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYWJsZVBhcmVudCA9PT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0U2Nyb2xsUG9zaXRpb24gPSBnZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdUb3AgPSB2aWV3cG9ydFNjcm9sbFBvc2l0aW9uLnRvcDtcclxuICAgICAgICAgICAgICAgIG5ld0xlZnQgPSB2aWV3cG9ydFNjcm9sbFBvc2l0aW9uLmxlZnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdUb3AgPSAoc2Nyb2xsYWJsZVBhcmVudCBhcyBIVE1MRWxlbWVudCkuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICAgICAgbmV3TGVmdCA9IChzY3JvbGxhYmxlUGFyZW50IGFzIEhUTUxFbGVtZW50KS5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0b3BEaWZmZXJlbmNlID0gc2Nyb2xsSW5pdGlhbFBvc2l0aW9uLnRvcCAtIG5ld1RvcDtcclxuICAgICAgICAgICAgY29uc3QgbGVmdERpZmZlcmVuY2UgPSBzY3JvbGxJbml0aWFsUG9zaXRpb24ubGVmdCAtIG5ld0xlZnQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge3RvcDogdG9wRGlmZmVyZW5jZSwgbGVmdDogbGVmdERpZmZlcmVuY2V9O1xyXG4gICAgICAgIH0pXHJcbiAgICApO1xyXG5cclxufVxyXG5cclxuLyoqIFJldHVybnMgdGhlIHZpZXdwb3J0J3Mgd2lkdGggYW5kIGhlaWdodC4gKi9cclxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRTaXplKCk6IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSB7XHJcbiAgICBjb25zdCBfd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogX3dpbmRvdy5pbm5lcldpZHRoLFxyXG4gICAgICAgIGhlaWdodDogX3dpbmRvdy5pbm5lckhlaWdodFxyXG4gICAgfTtcclxuXHJcbn1cclxuXHJcbi8qKiBHZXRzIGEgQ2xpZW50UmVjdCBmb3IgdGhlIHZpZXdwb3J0J3MgYm91bmRzLiAqL1xyXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoKTogQ2xpZW50UmVjdCB7XHJcbiAgICAvLyBVc2UgdGhlIGRvY3VtZW50IGVsZW1lbnQncyBib3VuZGluZyByZWN0IHJhdGhlciB0aGFuIHRoZSB3aW5kb3cgc2Nyb2xsIHByb3BlcnRpZXNcclxuICAgIC8vIChlLmcuIHBhZ2VZT2Zmc2V0LCBzY3JvbGxZKSBkdWUgdG8gaW4gaXNzdWUgaW4gQ2hyb21lIGFuZCBJRSB3aGVyZSB3aW5kb3cgc2Nyb2xsXHJcbiAgICAvLyBwcm9wZXJ0aWVzIGFuZCBjbGllbnQgY29vcmRpbmF0ZXMgKGJvdW5kaW5nQ2xpZW50UmVjdCwgY2xpZW50WC9ZLCBldGMuKSBhcmUgaW4gZGlmZmVyZW50XHJcbiAgICAvLyBjb25jZXB0dWFsIHZpZXdwb3J0cy4gVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIHRoZXNlIHZpZXdwb3J0cyBhcmUgZXF1aXZhbGVudCwgYnV0IHRoZXlcclxuICAgIC8vIGNhbiBkaXNhZ3JlZSB3aGVuIHRoZSBwYWdlIGlzIHBpbmNoLXpvb21lZCAob24gZGV2aWNlcyB0aGF0IHN1cHBvcnQgdG91Y2gpLlxyXG4gICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ4OTIwNiNjNFxyXG4gICAgLy8gV2UgdXNlIHRoZSBkb2N1bWVudEVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgYm9keSBiZWNhdXNlLCBieSBkZWZhdWx0ICh3aXRob3V0IGEgY3NzIHJlc2V0KVxyXG4gICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGdpdmUgdGhlIGRvY3VtZW50IGJvZHkgYW4gOHB4IG1hcmdpbiwgd2hpY2ggaXMgbm90IGluY2x1ZGVkIGluXHJcbiAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5cclxuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbigpO1xyXG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZ2V0Vmlld3BvcnRTaXplKCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0b3A6IHNjcm9sbFBvc2l0aW9uLnRvcCxcclxuICAgICAgICBsZWZ0OiBzY3JvbGxQb3NpdGlvbi5sZWZ0LFxyXG4gICAgICAgIGJvdHRvbTogc2Nyb2xsUG9zaXRpb24udG9wICsgaGVpZ2h0LFxyXG4gICAgICAgIHJpZ2h0OiBzY3JvbGxQb3NpdGlvbi5sZWZ0ICsgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgIHdpZHRoLFxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqIEdldHMgdGhlICh0b3AsIGxlZnQpIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnQuICovXHJcbmZ1bmN0aW9uIGdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oKTogeyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyIH0ge1xyXG5cclxuICAgIC8vIFRoZSB0b3AtbGVmdC1jb3JuZXIgb2YgdGhlIHZpZXdwb3J0IGlzIGRldGVybWluZWQgYnkgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZG9jdW1lbnRcclxuICAgIC8vIGJvZHksIG5vcm1hbGx5IGp1c3QgKHNjcm9sbExlZnQsIHNjcm9sbFRvcCkuIEhvd2V2ZXIsIENocm9tZSBhbmQgRmlyZWZveCBkaXNhZ3JlZSBhYm91dFxyXG4gICAgLy8gd2hldGhlciBgZG9jdW1lbnQuYm9keWAgb3IgYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGAgaXMgdGhlIHNjcm9sbGVkIGVsZW1lbnQsIHNvIHJlYWRpbmdcclxuICAgIC8vIGBzY3JvbGxUb3BgIGFuZCBgc2Nyb2xsTGVmdGAgaXMgaW5jb25zaXN0ZW50LiBIb3dldmVyLCB1c2luZyB0aGUgYm91bmRpbmcgcmVjdCBvZlxyXG4gICAgLy8gYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGAgd29ya3MgY29uc2lzdGVudGx5LCB3aGVyZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCB2YWx1ZXMgd2lsbFxyXG4gICAgLy8gZXF1YWwgbmVnYXRpdmUgdGhlIHNjcm9sbCBwb3NpdGlvbi5cclxuICAgIGNvbnN0IHdpbmRvd1JlZiA9IGRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcclxuICAgIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCE7XHJcbiAgICBjb25zdCBkb2N1bWVudFJlY3QgPSBkb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgY29uc3QgdG9wID0gLWRvY3VtZW50UmVjdC50b3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgd2luZG93UmVmLnNjcm9sbFkgfHxcclxuICAgICAgICBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IDA7XHJcblxyXG4gICAgY29uc3QgbGVmdCA9IC1kb2N1bWVudFJlY3QubGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgd2luZG93UmVmLnNjcm9sbFggfHxcclxuICAgICAgICBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xyXG5cclxuICAgIHJldHVybiB7dG9wLCBsZWZ0fTtcclxufVxyXG5cclxuLyoqIFJldHVybnMgdGhlIGRvY3VtZW50IHNjcm9sbCB3aWR0aCAqL1xyXG5mdW5jdGlvbiBnZXREb2N1bWVudFNjcm9sbFdpZHRoKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsV2lkdGgsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCk7XHJcbn1cclxuXHJcbiJdfQ==