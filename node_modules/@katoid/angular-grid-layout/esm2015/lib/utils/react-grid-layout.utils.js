/**
 * IMPORTANT:
 * This utils are taken from the project: https://github.com/STRML/react-grid-layout.
 * The code should be as less modified as possible for easy maintenance.
 */
const DEBUG = false;
/**
 * Return the bottom coordinate of the layout.
 *
 * @param  {Array} layout Layout array.
 * @return {Number}       Bottom coordinate.
 */
export function bottom(layout) {
    let max = 0, bottomY;
    for (let i = 0, len = layout.length; i < len; i++) {
        bottomY = layout[i].y + layout[i].h;
        if (bottomY > max) {
            max = bottomY;
        }
    }
    return max;
}
export function cloneLayout(layout) {
    const newLayout = Array(layout.length);
    for (let i = 0, len = layout.length; i < len; i++) {
        newLayout[i] = cloneLayoutItem(layout[i]);
    }
    return newLayout;
}
// Fast path to cloning, since this is monomorphic
/** NOTE: This code has been modified from the original source */
export function cloneLayoutItem(layoutItem) {
    const clonedLayoutItem = {
        w: layoutItem.w,
        h: layoutItem.h,
        x: layoutItem.x,
        y: layoutItem.y,
        id: layoutItem.id,
        moved: !!layoutItem.moved,
        static: !!layoutItem.static,
    };
    if (layoutItem.minW !== undefined) {
        clonedLayoutItem.minW = layoutItem.minW;
    }
    if (layoutItem.maxW !== undefined) {
        clonedLayoutItem.maxW = layoutItem.maxW;
    }
    if (layoutItem.minH !== undefined) {
        clonedLayoutItem.minH = layoutItem.minH;
    }
    if (layoutItem.maxH !== undefined) {
        clonedLayoutItem.maxH = layoutItem.maxH;
    }
    // These can be null
    if (layoutItem.isDraggable !== undefined) {
        clonedLayoutItem.isDraggable = layoutItem.isDraggable;
    }
    if (layoutItem.isResizable !== undefined) {
        clonedLayoutItem.isResizable = layoutItem.isResizable;
    }
    return clonedLayoutItem;
}
/**
 * Given two layoutitems, check if they collide.
 */
export function collides(l1, l2) {
    if (l1.id === l2.id) {
        return false;
    } // same element
    if (l1.x + l1.w <= l2.x) {
        return false;
    } // l1 is left of l2
    if (l1.x >= l2.x + l2.w) {
        return false;
    } // l1 is right of l2
    if (l1.y + l1.h <= l2.y) {
        return false;
    } // l1 is above l2
    if (l1.y >= l2.y + l2.h) {
        return false;
    } // l1 is below l2
    return true; // boxes overlap
}
/**
 * Given a layout, compact it. This involves going down each y coordinate and removing gaps
 * between items.
 *
 * @param  {Array} layout Layout.
 * @param  {Boolean} verticalCompact Whether or not to compact the layout
 *   vertically.
 * @return {Array}       Compacted Layout.
 */
export function compact(layout, compactType, cols) {
    // Statics go in the compareWith array right away so items flow around them.
    const compareWith = getStatics(layout);
    // We go through the items by row and column.
    const sorted = sortLayoutItems(layout, compactType);
    // Holding for new items.
    const out = Array(layout.length);
    for (let i = 0, len = sorted.length; i < len; i++) {
        let l = cloneLayoutItem(sorted[i]);
        // Don't move static elements
        if (!l.static) {
            l = compactItem(compareWith, l, compactType, cols, sorted);
            // Add to comparison array. We only collide with items before this one.
            // Statics are already in this array.
            compareWith.push(l);
        }
        // Add to output array to make sure they still come out in the right order.
        out[layout.indexOf(sorted[i])] = l;
        // Clear moved flag, if it exists.
        l.moved = false;
    }
    return out;
}
const heightWidth = { x: 'w', y: 'h' };
/**
 * Before moving item down, it will check if the movement will cause collisions and move those items down before.
 */
function resolveCompactionCollision(layout, item, moveToCoord, axis) {
    const sizeProp = heightWidth[axis];
    item[axis] += 1;
    const itemIndex = layout
        .map(layoutItem => {
        return layoutItem.id;
    })
        .indexOf(item.id);
    // Go through each item we collide with.
    for (let i = itemIndex + 1; i < layout.length; i++) {
        const otherItem = layout[i];
        // Ignore static items
        if (otherItem.static) {
            continue;
        }
        // Optimization: we can break early if we know we're past this el
        // We can do this b/c it's a sorted layout
        if (otherItem.y > item.y + item.h) {
            break;
        }
        if (collides(item, otherItem)) {
            resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);
        }
    }
    item[axis] = moveToCoord;
}
/**
 * Compact an item in the layout.
 */
export function compactItem(compareWith, l, compactType, cols, fullLayout) {
    const compactV = compactType === 'vertical';
    const compactH = compactType === 'horizontal';
    if (compactV) {
        // Bottom 'y' possible is the bottom of the layout.
        // This allows you to do nice stuff like specify {y: Infinity}
        // This is here because the layout must be sorted in order to get the correct bottom `y`.
        l.y = Math.min(bottom(compareWith), l.y);
        // Move the element up as far as it can go without colliding.
        while (l.y > 0 && !getFirstCollision(compareWith, l)) {
            l.y--;
        }
    }
    else if (compactH) {
        l.y = Math.min(bottom(compareWith), l.y);
        // Move the element left as far as it can go without colliding.
        while (l.x > 0 && !getFirstCollision(compareWith, l)) {
            l.x--;
        }
    }
    // Move it down, and keep moving it down if it's colliding.
    let collides;
    while ((collides = getFirstCollision(compareWith, l))) {
        if (compactH) {
            resolveCompactionCollision(fullLayout, l, collides.x + collides.w, 'x');
        }
        else {
            resolveCompactionCollision(fullLayout, l, collides.y + collides.h, 'y');
        }
        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.
        if (compactH && l.x + l.w > cols) {
            l.x = cols - l.w;
            l.y++;
        }
    }
    return l;
}
/**
 * Given a layout, make sure all elements fit within its bounds.
 *
 * @param  {Array} layout Layout array.
 * @param  {Number} bounds Number of columns.
 */
export function correctBounds(layout, bounds) {
    const collidesWith = getStatics(layout);
    for (let i = 0, len = layout.length; i < len; i++) {
        const l = layout[i];
        // Overflows right
        if (l.x + l.w > bounds.cols) {
            l.x = bounds.cols - l.w;
        }
        // Overflows left
        if (l.x < 0) {
            l.x = 0;
            l.w = bounds.cols;
        }
        if (!l.static) {
            collidesWith.push(l);
        }
        else {
            // If this is static and collides with other statics, we must move it down.
            // We have to do something nicer than just letting them overlap.
            while (getFirstCollision(collidesWith, l)) {
                l.y++;
            }
        }
    }
    return layout;
}
/**
 * Get a layout item by ID. Used so we can override later on if necessary.
 *
 * @param  {Array}  layout Layout array.
 * @param  {String} id     ID
 * @return {LayoutItem}    Item at ID.
 */
export function getLayoutItem(layout, id) {
    for (let i = 0, len = layout.length; i < len; i++) {
        if (layout[i].id === id) {
            return layout[i];
        }
    }
    return null;
}
/**
 * Returns the first item this layout collides with.
 * It doesn't appear to matter which order we approach this from, although
 * perhaps that is the wrong thing to do.
 *
 * @param  {Object} layoutItem Layout item.
 * @return {Object|undefined}  A colliding layout item, or undefined.
 */
export function getFirstCollision(layout, layoutItem) {
    for (let i = 0, len = layout.length; i < len; i++) {
        if (collides(layout[i], layoutItem)) {
            return layout[i];
        }
    }
    return null;
}
export function getAllCollisions(layout, layoutItem) {
    return layout.filter(l => collides(l, layoutItem));
}
/**
 * Get all static elements.
 * @param  {Array} layout Array of layout objects.
 * @return {Array}        Array of static layout items..
 */
export function getStatics(layout) {
    return layout.filter(l => l.static);
}
/**
 * Move an element. Responsible for doing cascading movements of other elements.
 *
 * @param  {Array}      layout            Full layout to modify.
 * @param  {LayoutItem} l                 element to move.
 * @param  {Number}     [x]               X position in grid units.
 * @param  {Number}     [y]               Y position in grid units.
 */
export function moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {
    // If this is static and not explicitly enabled as draggable,
    // no move is possible, so we can short-circuit this immediately.
    if (l.static && l.isDraggable !== true) {
        return layout;
    }
    // Short-circuit if nothing to do.
    if (l.y === y && l.x === x) {
        return layout;
    }
    log(`Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);
    const oldX = l.x;
    const oldY = l.y;
    // This is quite a bit faster than extending the object
    if (typeof x === 'number') {
        l.x = x;
    }
    if (typeof y === 'number') {
        l.y = y;
    }
    l.moved = true;
    // If this collides with anything, move it.
    // When doing this comparison, we have to sort the items we compare with
    // to ensure, in the case of multiple collisions, that we're getting the
    // nearest collision.
    let sorted = sortLayoutItems(layout, compactType);
    const movingUp = compactType === 'vertical' && typeof y === 'number'
        ? oldY >= y
        : compactType === 'horizontal' && typeof x === 'number'
            ? oldX >= x
            : false;
    if (movingUp) {
        sorted = sorted.reverse();
    }
    const collisions = getAllCollisions(sorted, l);
    // There was a collision; abort
    if (preventCollision && collisions.length) {
        log(`Collision prevented on ${l.id}, reverting.`);
        l.x = oldX;
        l.y = oldY;
        l.moved = false;
        return layout;
    }
    // Move each item that collides away from this element.
    for (let i = 0, len = collisions.length; i < len; i++) {
        const collision = collisions[i];
        log(`Resolving collision between ${l.id} at [${l.x},${l.y}] and ${collision.id} at [${collision.x},${collision.y}]`);
        // Short circuit so we can't infinite loop
        if (collision.moved) {
            continue;
        }
        // Don't move static items - we have to move *this* element away
        if (collision.static) {
            layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);
        }
        else {
            layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);
        }
    }
    return layout;
}
/**
 * This is where the magic needs to happen - given a collision, move an element away from the collision.
 * We attempt to move it up if there's room, otherwise it goes below.
 *
 * @param  {Array} layout            Full layout to modify.
 * @param  {LayoutItem} collidesWith Layout item we're colliding with.
 * @param  {LayoutItem} itemToMove   Layout item we're moving.
 */
export function moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {
    const compactH = compactType === 'horizontal';
    // Compact vertically if not set to horizontal
    const compactV = compactType !== 'horizontal';
    const preventCollision = collidesWith.static; // we're already colliding (not for static items)
    // If there is enough space above the collision to put this element, move it there.
    // We only do this on the main collision as this can get funky in cascades and cause
    // unwanted swapping behavior.
    if (isUserAction) {
        // Reset isUserAction flag because we're not in the main collision anymore.
        isUserAction = false;
        // Make a mock item so we don't modify the item here, only modify in moveElement.
        const fakeItem = {
            x: compactH
                ? Math.max(collidesWith.x - itemToMove.w, 0)
                : itemToMove.x,
            y: compactV
                ? Math.max(collidesWith.y - itemToMove.h, 0)
                : itemToMove.y,
            w: itemToMove.w,
            h: itemToMove.h,
            id: '-1',
        };
        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal
        if (!getFirstCollision(layout, fakeItem)) {
            log(`Doing reverse collision on ${itemToMove.id} up to [${fakeItem.x},${fakeItem.y}].`);
            return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);
        }
    }
    return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);
}
/**
 * Helper to convert a number to a percentage string.
 *
 * @param  {Number} num Any number
 * @return {String}     That number as a percentage.
 */
export function perc(num) {
    return num * 100 + '%';
}
export function setTransform({ top, left, width, height }) {
    // Replace unitless items with px
    const translate = `translate(${left}px,${top}px)`;
    return {
        transform: translate,
        WebkitTransform: translate,
        MozTransform: translate,
        msTransform: translate,
        OTransform: translate,
        width: `${width}px`,
        height: `${height}px`,
        position: 'absolute',
    };
}
export function setTopLeft({ top, left, width, height }) {
    return {
        top: `${top}px`,
        left: `${left}px`,
        width: `${width}px`,
        height: `${height}px`,
        position: 'absolute',
    };
}
/**
 * Get layout items sorted from top left to right and down.
 *
 * @return {Array} Array of layout objects.
 * @return {Array}        Layout, sorted static items first.
 */
export function sortLayoutItems(layout, compactType) {
    if (compactType === 'horizontal') {
        return sortLayoutItemsByColRow(layout);
    }
    else {
        return sortLayoutItemsByRowCol(layout);
    }
}
export function sortLayoutItemsByRowCol(layout) {
    return [].concat(layout).sort(function (a, b) {
        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {
            return 1;
        }
        else if (a.y === b.y && a.x === b.x) {
            // Without this, we can get different sort results in IE vs. Chrome/FF
            return 0;
        }
        return -1;
    });
}
export function sortLayoutItemsByColRow(layout) {
    return [].concat(layout).sort(function (a, b) {
        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {
            return 1;
        }
        return -1;
    });
}
/**
 * Validate a layout. Throws errors.
 *
 * @param  {Array}  layout        Array of layout items.
 * @param  {String} [contextName] Context name for errors.
 * @throw  {Error}                Validation error.
 */
export function validateLayout(layout, contextName = 'Layout') {
    const subProps = ['x', 'y', 'w', 'h'];
    if (!Array.isArray(layout)) {
        throw new Error(contextName + ' must be an array!');
    }
    for (let i = 0, len = layout.length; i < len; i++) {
        const item = layout[i];
        for (let j = 0; j < subProps.length; j++) {
            if (typeof item[subProps[j]] !== 'number') {
                throw new Error('ReactGridLayout: ' +
                    contextName +
                    '[' +
                    i +
                    '].' +
                    subProps[j] +
                    ' must be a number!');
            }
        }
        if (item.id && typeof item.id !== 'string') {
            throw new Error('ReactGridLayout: ' +
                contextName +
                '[' +
                i +
                '].i must be a string!');
        }
        if (item.static !== undefined && typeof item.static !== 'boolean') {
            throw new Error('ReactGridLayout: ' +
                contextName +
                '[' +
                i +
                '].static must be a boolean!');
        }
    }
}
// Flow can't really figure this out, so we just use Object
export function autoBindHandlers(el, fns) {
    fns.forEach(key => (el[key] = el[key].bind(el)));
}
function log(...args) {
    if (!DEBUG) {
        return;
    }
    // eslint-disable-next-line no-console
    console.log(...args);
}
export const noop = () => { };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3QtZ3JpZC1sYXlvdXQudXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWdyaWQtbGF5b3V0L3NyYy9saWIvdXRpbHMvcmVhY3QtZ3JpZC1sYXlvdXQudXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0E7Ozs7R0FJRztBQXFFSCxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUM7QUFFcEI7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsTUFBTSxDQUFDLE1BQWM7SUFDakMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUNQLE9BQU8sQ0FBQztJQUNaLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsT0FBTyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwQyxJQUFJLE9BQU8sR0FBRyxHQUFHLEVBQUU7WUFDZixHQUFHLEdBQUcsT0FBTyxDQUFDO1NBQ2pCO0tBQ0o7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUM7QUFFRCxNQUFNLFVBQVUsV0FBVyxDQUFDLE1BQWM7SUFDdEMsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN2QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQy9DLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0M7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNyQixDQUFDO0FBRUQs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QztJQUN0QyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDekIsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLElBQUksR0FBRyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIElNUE9SVEFOVDpcclxuICogVGhpcyB1dGlscyBhcmUgdGFrZW4gZnJvbSB0aGUgcHJvamVjdDogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML3JlYWN0LWdyaWQtbGF5b3V0LlxyXG4gKiBUaGUgY29kZSBzaG91bGQgYmUgYXMgbGVzcyBtb2RpZmllZCBhcyBwb3NzaWJsZSBmb3IgZWFzeSBtYWludGVuYW5jZS5cclxuICovXHJcblxyXG4vLyBEaXNhYmxlIGxpbnQgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgdGhpcyBjb2RlXHJcbi8vIHRzbGludDpkaXNhYmxlXHJcbmV4cG9ydCB0eXBlIExheW91dEl0ZW0gPSB7XHJcbiAgICB3OiBudW1iZXI7XHJcbiAgICBoOiBudW1iZXI7XHJcbiAgICB4OiBudW1iZXI7XHJcbiAgICB5OiBudW1iZXI7XHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgbWluVz86IG51bWJlcjtcclxuICAgIG1pbkg/OiBudW1iZXI7XHJcbiAgICBtYXhXPzogbnVtYmVyO1xyXG4gICAgbWF4SD86IG51bWJlcjtcclxuICAgIG1vdmVkPzogYm9vbGVhbjtcclxuICAgIHN0YXRpYz86IGJvb2xlYW47XHJcbiAgICBpc0RyYWdnYWJsZT86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgaXNSZXNpemFibGU/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxufTtcclxuZXhwb3J0IHR5cGUgTGF5b3V0ID0gQXJyYXk8TGF5b3V0SXRlbT47XHJcbmV4cG9ydCB0eXBlIFBvc2l0aW9uID0ge1xyXG4gICAgbGVmdDogbnVtYmVyO1xyXG4gICAgdG9wOiBudW1iZXI7XHJcbiAgICB3aWR0aDogbnVtYmVyO1xyXG4gICAgaGVpZ2h0OiBudW1iZXI7XHJcbn07XHJcbmV4cG9ydCB0eXBlIFJlYWN0RHJhZ2dhYmxlQ2FsbGJhY2tEYXRhID0ge1xyXG4gICAgbm9kZTogSFRNTEVsZW1lbnQ7XHJcbiAgICB4PzogbnVtYmVyO1xyXG4gICAgeT86IG51bWJlcjtcclxuICAgIGRlbHRhWDogbnVtYmVyO1xyXG4gICAgZGVsdGFZOiBudW1iZXI7XHJcbiAgICBsYXN0WD86IG51bWJlcjtcclxuICAgIGxhc3RZPzogbnVtYmVyO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUGFydGlhbFBvc2l0aW9uID0geyBsZWZ0OiBudW1iZXI7IHRvcDogbnVtYmVyIH07XHJcbmV4cG9ydCB0eXBlIERyb3BwaW5nUG9zaXRpb24gPSB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBlOiBFdmVudCB9O1xyXG5leHBvcnQgdHlwZSBTaXplID0geyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9O1xyXG5leHBvcnQgdHlwZSBHcmlkRHJhZ0V2ZW50ID0ge1xyXG4gICAgZTogRXZlbnQ7XHJcbiAgICBub2RlOiBIVE1MRWxlbWVudDtcclxuICAgIG5ld1Bvc2l0aW9uOiBQYXJ0aWFsUG9zaXRpb247XHJcbn07XHJcbmV4cG9ydCB0eXBlIEdyaWRSZXNpemVFdmVudCA9IHsgZTogRXZlbnQ7IG5vZGU6IEhUTUxFbGVtZW50OyBzaXplOiBTaXplIH07XHJcbmV4cG9ydCB0eXBlIERyYWdPdmVyRXZlbnQgPSBNb3VzZUV2ZW50ICYge1xyXG4gICAgbmF0aXZlRXZlbnQ6IHtcclxuICAgICAgICBsYXllclg6IG51bWJlcjtcclxuICAgICAgICBsYXllclk6IG51bWJlcjtcclxuICAgICAgICB0YXJnZXQ6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBTdHJpbmc7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn07XHJcblxyXG4vL3R5cGUgUkVsID0gUmVhY3RFbGVtZW50PGFueT47XHJcbi8vZXhwb3J0IHR5cGUgUmVhY3RDaGlsZHJlbiA9IFJlYWN0Q2hpbGRyZW5BcnJheTxSRWw+O1xyXG5cclxuLy8gQWxsIGNhbGxiYWNrcyBhcmUgb2YgdGhlIHNpZ25hdHVyZSAobGF5b3V0LCBvbGRJdGVtLCBuZXdJdGVtLCBwbGFjZWhvbGRlciwgZSkuXHJcbmV4cG9ydCB0eXBlIEV2ZW50Q2FsbGJhY2sgPSAoXHJcbiAgICBhcmcwOiBMYXlvdXQsXHJcbiAgICBvbGRJdGVtOiBMYXlvdXRJdGVtIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICAgIG5ld0l0ZW06IExheW91dEl0ZW0gfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgcGxhY2Vob2xkZXI6IExheW91dEl0ZW0gfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgYXJnNDogRXZlbnQsXHJcbiAgICBhcmc1OiBIVE1MRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWQsXHJcbikgPT4gdm9pZDtcclxuZXhwb3J0IHR5cGUgQ29tcGFjdFR5cGUgPSAoJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJykgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG5cclxuY29uc3QgREVCVUcgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGJvdHRvbSBjb29yZGluYXRlIG9mIHRoZSBsYXlvdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgTGF5b3V0IGFycmF5LlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIEJvdHRvbSBjb29yZGluYXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJvdHRvbShsYXlvdXQ6IExheW91dCk6IG51bWJlciB7XHJcbiAgICBsZXQgbWF4ID0gMCxcclxuICAgICAgICBib3R0b21ZO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGJvdHRvbVkgPSBsYXlvdXRbaV0ueSArIGxheW91dFtpXS5oO1xyXG4gICAgICAgIGlmIChib3R0b21ZID4gbWF4KSB7XHJcbiAgICAgICAgICAgIG1heCA9IGJvdHRvbVk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1heDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lTGF5b3V0KGxheW91dDogTGF5b3V0KTogTGF5b3V0IHtcclxuICAgIGNvbnN0IG5ld0xheW91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIG5ld0xheW91dFtpXSA9IGNsb25lTGF5b3V0SXRlbShsYXlvdXRbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0xheW91dDtcclxufVxyXG5cclxuLy8gRmFzdCBwYXRoIHRvIGNsb25pbmcsIHNpbmNlIHRoaXMgaXMgbW9ub21vcnBoaWNcclxuLyoqIE5PVEU6IFRoaXMgY29kZSBoYXMgYmVlbiBtb2RpZmllZCBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lTGF5b3V0SXRlbShsYXlvdXRJdGVtOiBMYXlvdXRJdGVtKTogTGF5b3V0SXRlbSB7XHJcbiAgICBjb25zdCBjbG9uZWRMYXlvdXRJdGVtOiBMYXlvdXRJdGVtID0ge1xyXG4gICAgICAgIHc6IGxheW91dEl0ZW0udyxcclxuICAgICAgICBoOiBsYXlvdXRJdGVtLmgsXHJcbiAgICAgICAgeDogbGF5b3V0SXRlbS54LFxyXG4gICAgICAgIHk6IGxheW91dEl0ZW0ueSxcclxuICAgICAgICBpZDogbGF5b3V0SXRlbS5pZCxcclxuICAgICAgICBtb3ZlZDogISFsYXlvdXRJdGVtLm1vdmVkLFxyXG4gICAgICAgIHN0YXRpYzogISFsYXlvdXRJdGVtLnN0YXRpYyxcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGxheW91dEl0ZW0ubWluVyAhPT0gdW5kZWZpbmVkKSB7IGNsb25lZExheW91dEl0ZW0ubWluVyA9IGxheW91dEl0ZW0ubWluVzt9XHJcbiAgICBpZiAobGF5b3V0SXRlbS5tYXhXICE9PSB1bmRlZmluZWQpIHsgY2xvbmVkTGF5b3V0SXRlbS5tYXhXID0gbGF5b3V0SXRlbS5tYXhXO31cclxuICAgIGlmIChsYXlvdXRJdGVtLm1pbkggIT09IHVuZGVmaW5lZCkgeyBjbG9uZWRMYXlvdXRJdGVtLm1pbkggPSBsYXlvdXRJdGVtLm1pbkg7fVxyXG4gICAgaWYgKGxheW91dEl0ZW0ubWF4SCAhPT0gdW5kZWZpbmVkKSB7IGNsb25lZExheW91dEl0ZW0ubWF4SCA9IGxheW91dEl0ZW0ubWF4SDt9XHJcbiAgICAvLyBUaGVzZSBjYW4gYmUgbnVsbFxyXG4gICAgaWYgKGxheW91dEl0ZW0uaXNEcmFnZ2FibGUgIT09IHVuZGVmaW5lZCkgeyBjbG9uZWRMYXlvdXRJdGVtLmlzRHJhZ2dhYmxlID0gbGF5b3V0SXRlbS5pc0RyYWdnYWJsZTt9XHJcbiAgICBpZiAobGF5b3V0SXRlbS5pc1Jlc2l6YWJsZSAhPT0gdW5kZWZpbmVkKSB7IGNsb25lZExheW91dEl0ZW0uaXNSZXNpemFibGUgPSBsYXlvdXRJdGVtLmlzUmVzaXphYmxlO31cclxuXHJcbiAgICByZXR1cm4gY2xvbmVkTGF5b3V0SXRlbTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHR3byBsYXlvdXRpdGVtcywgY2hlY2sgaWYgdGhleSBjb2xsaWRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxpZGVzKGwxOiBMYXlvdXRJdGVtLCBsMjogTGF5b3V0SXRlbSk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGwxLmlkID09PSBsMi5pZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gLy8gc2FtZSBlbGVtZW50XHJcbiAgICBpZiAobDEueCArIGwxLncgPD0gbDIueCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gLy8gbDEgaXMgbGVmdCBvZiBsMlxyXG4gICAgaWYgKGwxLnggPj0gbDIueCArIGwyLncpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IC8vIGwxIGlzIHJpZ2h0IG9mIGwyXHJcbiAgICBpZiAobDEueSArIGwxLmggPD0gbDIueSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gLy8gbDEgaXMgYWJvdmUgbDJcclxuICAgIGlmIChsMS55ID49IGwyLnkgKyBsMi5oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSAvLyBsMSBpcyBiZWxvdyBsMlxyXG4gICAgcmV0dXJuIHRydWU7IC8vIGJveGVzIG92ZXJsYXBcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGF5b3V0LCBjb21wYWN0IGl0LiBUaGlzIGludm9sdmVzIGdvaW5nIGRvd24gZWFjaCB5IGNvb3JkaW5hdGUgYW5kIHJlbW92aW5nIGdhcHNcclxuICogYmV0d2VlbiBpdGVtcy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQuXHJcbiAqIEBwYXJhbSAge0Jvb2xlYW59IHZlcnRpY2FsQ29tcGFjdCBXaGV0aGVyIG9yIG5vdCB0byBjb21wYWN0IHRoZSBsYXlvdXRcclxuICogICB2ZXJ0aWNhbGx5LlxyXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQ29tcGFjdGVkIExheW91dC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYWN0KFxyXG4gICAgbGF5b3V0OiBMYXlvdXQsXHJcbiAgICBjb21wYWN0VHlwZTogQ29tcGFjdFR5cGUsXHJcbiAgICBjb2xzOiBudW1iZXIsXHJcbik6IExheW91dCB7XHJcbiAgICAvLyBTdGF0aWNzIGdvIGluIHRoZSBjb21wYXJlV2l0aCBhcnJheSByaWdodCBhd2F5IHNvIGl0ZW1zIGZsb3cgYXJvdW5kIHRoZW0uXHJcbiAgICBjb25zdCBjb21wYXJlV2l0aCA9IGdldFN0YXRpY3MobGF5b3V0KTtcclxuICAgIC8vIFdlIGdvIHRocm91Z2ggdGhlIGl0ZW1zIGJ5IHJvdyBhbmQgY29sdW1uLlxyXG4gICAgY29uc3Qgc29ydGVkID0gc29ydExheW91dEl0ZW1zKGxheW91dCwgY29tcGFjdFR5cGUpO1xyXG4gICAgLy8gSG9sZGluZyBmb3IgbmV3IGl0ZW1zLlxyXG4gICAgY29uc3Qgb3V0ID0gQXJyYXkobGF5b3V0Lmxlbmd0aCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNvcnRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGxldCBsID0gY2xvbmVMYXlvdXRJdGVtKHNvcnRlZFtpXSk7XHJcblxyXG4gICAgICAgIC8vIERvbid0IG1vdmUgc3RhdGljIGVsZW1lbnRzXHJcbiAgICAgICAgaWYgKCFsLnN0YXRpYykge1xyXG4gICAgICAgICAgICBsID0gY29tcGFjdEl0ZW0oY29tcGFyZVdpdGgsIGwsIGNvbXBhY3RUeXBlLCBjb2xzLCBzb3J0ZWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRvIGNvbXBhcmlzb24gYXJyYXkuIFdlIG9ubHkgY29sbGlkZSB3aXRoIGl0ZW1zIGJlZm9yZSB0aGlzIG9uZS5cclxuICAgICAgICAgICAgLy8gU3RhdGljcyBhcmUgYWxyZWFkeSBpbiB0aGlzIGFycmF5LlxyXG4gICAgICAgICAgICBjb21wYXJlV2l0aC5wdXNoKGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIHRvIG91dHB1dCBhcnJheSB0byBtYWtlIHN1cmUgdGhleSBzdGlsbCBjb21lIG91dCBpbiB0aGUgcmlnaHQgb3JkZXIuXHJcbiAgICAgICAgb3V0W2xheW91dC5pbmRleE9mKHNvcnRlZFtpXSldID0gbDtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgbW92ZWQgZmxhZywgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgIGwubW92ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG5jb25zdCBoZWlnaHRXaWR0aCA9IHt4OiAndycsIHk6ICdoJ307XHJcblxyXG4vKipcclxuICogQmVmb3JlIG1vdmluZyBpdGVtIGRvd24sIGl0IHdpbGwgY2hlY2sgaWYgdGhlIG1vdmVtZW50IHdpbGwgY2F1c2UgY29sbGlzaW9ucyBhbmQgbW92ZSB0aG9zZSBpdGVtcyBkb3duIGJlZm9yZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKFxyXG4gICAgbGF5b3V0OiBMYXlvdXQsXHJcbiAgICBpdGVtOiBMYXlvdXRJdGVtLFxyXG4gICAgbW92ZVRvQ29vcmQ6IG51bWJlcixcclxuICAgIGF4aXM6ICd4JyB8ICd5JyxcclxuKSB7XHJcbiAgICBjb25zdCBzaXplUHJvcCA9IGhlaWdodFdpZHRoW2F4aXNdO1xyXG4gICAgaXRlbVtheGlzXSArPSAxO1xyXG4gICAgY29uc3QgaXRlbUluZGV4ID0gbGF5b3V0XHJcbiAgICAgICAgLm1hcChsYXlvdXRJdGVtID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxheW91dEl0ZW0uaWQ7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuaW5kZXhPZihpdGVtLmlkKTtcclxuXHJcbiAgICAvLyBHbyB0aHJvdWdoIGVhY2ggaXRlbSB3ZSBjb2xsaWRlIHdpdGguXHJcbiAgICBmb3IgKGxldCBpID0gaXRlbUluZGV4ICsgMTsgaSA8IGxheW91dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG90aGVySXRlbSA9IGxheW91dFtpXTtcclxuICAgICAgICAvLyBJZ25vcmUgc3RhdGljIGl0ZW1zXHJcbiAgICAgICAgaWYgKG90aGVySXRlbS5zdGF0aWMpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPcHRpbWl6YXRpb246IHdlIGNhbiBicmVhayBlYXJseSBpZiB3ZSBrbm93IHdlJ3JlIHBhc3QgdGhpcyBlbFxyXG4gICAgICAgIC8vIFdlIGNhbiBkbyB0aGlzIGIvYyBpdCdzIGEgc29ydGVkIGxheW91dFxyXG4gICAgICAgIGlmIChvdGhlckl0ZW0ueSA+IGl0ZW0ueSArIGl0ZW0uaCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb2xsaWRlcyhpdGVtLCBvdGhlckl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKFxyXG4gICAgICAgICAgICAgICAgbGF5b3V0LFxyXG4gICAgICAgICAgICAgICAgb3RoZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgbW92ZVRvQ29vcmQgKyBpdGVtW3NpemVQcm9wXSxcclxuICAgICAgICAgICAgICAgIGF4aXMsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGl0ZW1bYXhpc10gPSBtb3ZlVG9Db29yZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXBhY3QgYW4gaXRlbSBpbiB0aGUgbGF5b3V0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3RJdGVtKFxyXG4gICAgY29tcGFyZVdpdGg6IExheW91dCxcclxuICAgIGw6IExheW91dEl0ZW0sXHJcbiAgICBjb21wYWN0VHlwZTogQ29tcGFjdFR5cGUsXHJcbiAgICBjb2xzOiBudW1iZXIsXHJcbiAgICBmdWxsTGF5b3V0OiBMYXlvdXQsXHJcbik6IExheW91dEl0ZW0ge1xyXG4gICAgY29uc3QgY29tcGFjdFYgPSBjb21wYWN0VHlwZSA9PT0gJ3ZlcnRpY2FsJztcclxuICAgIGNvbnN0IGNvbXBhY3RIID0gY29tcGFjdFR5cGUgPT09ICdob3Jpem9udGFsJztcclxuICAgIGlmIChjb21wYWN0Vikge1xyXG4gICAgICAgIC8vIEJvdHRvbSAneScgcG9zc2libGUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgbGF5b3V0LlxyXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBkbyBuaWNlIHN0dWZmIGxpa2Ugc3BlY2lmeSB7eTogSW5maW5pdHl9XHJcbiAgICAgICAgLy8gVGhpcyBpcyBoZXJlIGJlY2F1c2UgdGhlIGxheW91dCBtdXN0IGJlIHNvcnRlZCBpbiBvcmRlciB0byBnZXQgdGhlIGNvcnJlY3QgYm90dG9tIGB5YC5cclxuICAgICAgICBsLnkgPSBNYXRoLm1pbihib3R0b20oY29tcGFyZVdpdGgpLCBsLnkpO1xyXG4gICAgICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdXAgYXMgZmFyIGFzIGl0IGNhbiBnbyB3aXRob3V0IGNvbGxpZGluZy5cclxuICAgICAgICB3aGlsZSAobC55ID4gMCAmJiAhZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSB7XHJcbiAgICAgICAgICAgIGwueS0tO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY29tcGFjdEgpIHtcclxuICAgICAgICBsLnkgPSBNYXRoLm1pbihib3R0b20oY29tcGFyZVdpdGgpLCBsLnkpO1xyXG4gICAgICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgbGVmdCBhcyBmYXIgYXMgaXQgY2FuIGdvIHdpdGhvdXQgY29sbGlkaW5nLlxyXG4gICAgICAgIHdoaWxlIChsLnggPiAwICYmICFnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpIHtcclxuICAgICAgICAgICAgbC54LS07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1vdmUgaXQgZG93biwgYW5kIGtlZXAgbW92aW5nIGl0IGRvd24gaWYgaXQncyBjb2xsaWRpbmcuXHJcbiAgICBsZXQgY29sbGlkZXM7XHJcbiAgICB3aGlsZSAoKGNvbGxpZGVzID0gZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSkge1xyXG4gICAgICAgIGlmIChjb21wYWN0SCkge1xyXG4gICAgICAgICAgICByZXNvbHZlQ29tcGFjdGlvbkNvbGxpc2lvbihcclxuICAgICAgICAgICAgICAgIGZ1bGxMYXlvdXQsXHJcbiAgICAgICAgICAgICAgICBsLFxyXG4gICAgICAgICAgICAgICAgY29sbGlkZXMueCArIGNvbGxpZGVzLncsXHJcbiAgICAgICAgICAgICAgICAneCcsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZUNvbXBhY3Rpb25Db2xsaXNpb24oXHJcbiAgICAgICAgICAgICAgICBmdWxsTGF5b3V0LFxyXG4gICAgICAgICAgICAgICAgbCxcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVzLnkgKyBjb2xsaWRlcy5oLFxyXG4gICAgICAgICAgICAgICAgJ3knLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBncm93IHdpdGhvdXQgYm91bmRzIGhvcml6b250YWxseSwgaWYgd2UndmUgb3ZlcmZsb3duLCBsZXQncyBtb3ZlIGl0IGRvd24gYW5kIHRyeSBhZ2Fpbi5cclxuICAgICAgICBpZiAoY29tcGFjdEggJiYgbC54ICsgbC53ID4gY29scykge1xyXG4gICAgICAgICAgICBsLnggPSBjb2xzIC0gbC53O1xyXG4gICAgICAgICAgICBsLnkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGF5b3V0LCBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGZpdCB3aXRoaW4gaXRzIGJvdW5kcy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYm91bmRzIE51bWJlciBvZiBjb2x1bW5zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcnJlY3RCb3VuZHMobGF5b3V0OiBMYXlvdXQsIGJvdW5kczogeyBjb2xzOiBudW1iZXIgfSk6IExheW91dCB7XHJcbiAgICBjb25zdCBjb2xsaWRlc1dpdGggPSBnZXRTdGF0aWNzKGxheW91dCk7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbCA9IGxheW91dFtpXTtcclxuICAgICAgICAvLyBPdmVyZmxvd3MgcmlnaHRcclxuICAgICAgICBpZiAobC54ICsgbC53ID4gYm91bmRzLmNvbHMpIHtcclxuICAgICAgICAgICAgbC54ID0gYm91bmRzLmNvbHMgLSBsLnc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE92ZXJmbG93cyBsZWZ0XHJcbiAgICAgICAgaWYgKGwueCA8IDApIHtcclxuICAgICAgICAgICAgbC54ID0gMDtcclxuICAgICAgICAgICAgbC53ID0gYm91bmRzLmNvbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbC5zdGF0aWMpIHtcclxuICAgICAgICAgICAgY29sbGlkZXNXaXRoLnB1c2gobCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBzdGF0aWMgYW5kIGNvbGxpZGVzIHdpdGggb3RoZXIgc3RhdGljcywgd2UgbXVzdCBtb3ZlIGl0IGRvd24uXHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZG8gc29tZXRoaW5nIG5pY2VyIHRoYW4ganVzdCBsZXR0aW5nIHRoZW0gb3ZlcmxhcC5cclxuICAgICAgICAgICAgd2hpbGUgKGdldEZpcnN0Q29sbGlzaW9uKGNvbGxpZGVzV2l0aCwgbCkpIHtcclxuICAgICAgICAgICAgICAgIGwueSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxheW91dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGxheW91dCBpdGVtIGJ5IElELiBVc2VkIHNvIHdlIGNhbiBvdmVycmlkZSBsYXRlciBvbiBpZiBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgbGF5b3V0IExheW91dCBhcnJheS5cclxuICogQHBhcmFtICB7U3RyaW5nfSBpZCAgICAgSURcclxuICogQHJldHVybiB7TGF5b3V0SXRlbX0gICAgSXRlbSBhdCBJRC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXlvdXRJdGVtKFxyXG4gICAgbGF5b3V0OiBMYXlvdXQsXHJcbiAgICBpZDogc3RyaW5nLFxyXG4pOiBMYXlvdXRJdGVtIHwgbnVsbCB8IHVuZGVmaW5lZCB7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGxheW91dFtpXS5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxheW91dFtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gdGhpcyBsYXlvdXQgY29sbGlkZXMgd2l0aC5cclxuICogSXQgZG9lc24ndCBhcHBlYXIgdG8gbWF0dGVyIHdoaWNoIG9yZGVyIHdlIGFwcHJvYWNoIHRoaXMgZnJvbSwgYWx0aG91Z2hcclxuICogcGVyaGFwcyB0aGF0IGlzIHRoZSB3cm9uZyB0aGluZyB0byBkby5cclxuICpcclxuICogQHBhcmFtICB7T2JqZWN0fSBsYXlvdXRJdGVtIExheW91dCBpdGVtLlxyXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSAgQSBjb2xsaWRpbmcgbGF5b3V0IGl0ZW0sIG9yIHVuZGVmaW5lZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaXJzdENvbGxpc2lvbihcclxuICAgIGxheW91dDogTGF5b3V0LFxyXG4gICAgbGF5b3V0SXRlbTogTGF5b3V0SXRlbSxcclxuKTogTGF5b3V0SXRlbSB8IG51bGwgfCB1bmRlZmluZWQge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChjb2xsaWRlcyhsYXlvdXRbaV0sIGxheW91dEl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb2xsaXNpb25zKFxyXG4gICAgbGF5b3V0OiBMYXlvdXQsXHJcbiAgICBsYXlvdXRJdGVtOiBMYXlvdXRJdGVtLFxyXG4pOiBBcnJheTxMYXlvdXRJdGVtPiB7XHJcbiAgICByZXR1cm4gbGF5b3V0LmZpbHRlcihsID0+IGNvbGxpZGVzKGwsIGxheW91dEl0ZW0pKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhbGwgc3RhdGljIGVsZW1lbnRzLlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IEFycmF5IG9mIGxheW91dCBvYmplY3RzLlxyXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgIEFycmF5IG9mIHN0YXRpYyBsYXlvdXQgaXRlbXMuLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXRpY3MobGF5b3V0OiBMYXlvdXQpOiBBcnJheTxMYXlvdXRJdGVtPiB7XHJcbiAgICByZXR1cm4gbGF5b3V0LmZpbHRlcihsID0+IGwuc3RhdGljKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1vdmUgYW4gZWxlbWVudC4gUmVzcG9uc2libGUgZm9yIGRvaW5nIGNhc2NhZGluZyBtb3ZlbWVudHMgb2Ygb3RoZXIgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxheW91dCAgICAgICAgICAgIEZ1bGwgbGF5b3V0IHRvIG1vZGlmeS5cclxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gbCAgICAgICAgICAgICAgICAgZWxlbWVudCB0byBtb3ZlLlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBbeF0gICAgICAgICAgICAgICBYIHBvc2l0aW9uIGluIGdyaWQgdW5pdHMuXHJcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIFt5XSAgICAgICAgICAgICAgIFkgcG9zaXRpb24gaW4gZ3JpZCB1bml0cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtb3ZlRWxlbWVudChcclxuICAgIGxheW91dDogTGF5b3V0LFxyXG4gICAgbDogTGF5b3V0SXRlbSxcclxuICAgIHg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsXHJcbiAgICB5OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgaXNVc2VyQWN0aW9uOiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICAgIHByZXZlbnRDb2xsaXNpb246IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkLFxyXG4gICAgY29tcGFjdFR5cGU6IENvbXBhY3RUeXBlLFxyXG4gICAgY29sczogbnVtYmVyLFxyXG4pOiBMYXlvdXQge1xyXG4gICAgLy8gSWYgdGhpcyBpcyBzdGF0aWMgYW5kIG5vdCBleHBsaWNpdGx5IGVuYWJsZWQgYXMgZHJhZ2dhYmxlLFxyXG4gICAgLy8gbm8gbW92ZSBpcyBwb3NzaWJsZSwgc28gd2UgY2FuIHNob3J0LWNpcmN1aXQgdGhpcyBpbW1lZGlhdGVseS5cclxuICAgIGlmIChsLnN0YXRpYyAmJiBsLmlzRHJhZ2dhYmxlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxheW91dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIG5vdGhpbmcgdG8gZG8uXHJcbiAgICBpZiAobC55ID09PSB5ICYmIGwueCA9PT0geCkge1xyXG4gICAgICAgIHJldHVybiBsYXlvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgbG9nKFxyXG4gICAgICAgIGBNb3ZpbmcgZWxlbWVudCAke2wuaWR9IHRvIFske1N0cmluZyh4KX0sJHtTdHJpbmcoeSl9XSBmcm9tIFske2wueH0sJHtcclxuICAgICAgICAgICAgbC55XHJcbiAgICAgICAgfV1gLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IG9sZFggPSBsLng7XHJcbiAgICBjb25zdCBvbGRZID0gbC55O1xyXG5cclxuICAgIC8vIFRoaXMgaXMgcXVpdGUgYSBiaXQgZmFzdGVyIHRoYW4gZXh0ZW5kaW5nIHRoZSBvYmplY3RcclxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBsLnggPSB4O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGwueSA9IHk7XHJcbiAgICB9XHJcbiAgICBsLm1vdmVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBJZiB0aGlzIGNvbGxpZGVzIHdpdGggYW55dGhpbmcsIG1vdmUgaXQuXHJcbiAgICAvLyBXaGVuIGRvaW5nIHRoaXMgY29tcGFyaXNvbiwgd2UgaGF2ZSB0byBzb3J0IHRoZSBpdGVtcyB3ZSBjb21wYXJlIHdpdGhcclxuICAgIC8vIHRvIGVuc3VyZSwgaW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgY29sbGlzaW9ucywgdGhhdCB3ZSdyZSBnZXR0aW5nIHRoZVxyXG4gICAgLy8gbmVhcmVzdCBjb2xsaXNpb24uXHJcbiAgICBsZXQgc29ydGVkID0gc29ydExheW91dEl0ZW1zKGxheW91dCwgY29tcGFjdFR5cGUpO1xyXG4gICAgY29uc3QgbW92aW5nVXAgPVxyXG4gICAgICAgIGNvbXBhY3RUeXBlID09PSAndmVydGljYWwnICYmIHR5cGVvZiB5ID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICA/IG9sZFkgPj0geVxyXG4gICAgICAgICAgICA6IGNvbXBhY3RUeXBlID09PSAnaG9yaXpvbnRhbCcgJiYgdHlwZW9mIHggPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgID8gb2xkWCA+PSB4XHJcbiAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICBpZiAobW92aW5nVXApIHtcclxuICAgICAgICBzb3J0ZWQgPSBzb3J0ZWQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29sbGlzaW9ucyA9IGdldEFsbENvbGxpc2lvbnMoc29ydGVkLCBsKTtcclxuXHJcbiAgICAvLyBUaGVyZSB3YXMgYSBjb2xsaXNpb247IGFib3J0XHJcbiAgICBpZiAocHJldmVudENvbGxpc2lvbiAmJiBjb2xsaXNpb25zLmxlbmd0aCkge1xyXG4gICAgICAgIGxvZyhgQ29sbGlzaW9uIHByZXZlbnRlZCBvbiAke2wuaWR9LCByZXZlcnRpbmcuYCk7XHJcbiAgICAgICAgbC54ID0gb2xkWDtcclxuICAgICAgICBsLnkgPSBvbGRZO1xyXG4gICAgICAgIGwubW92ZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gbGF5b3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1vdmUgZWFjaCBpdGVtIHRoYXQgY29sbGlkZXMgYXdheSBmcm9tIHRoaXMgZWxlbWVudC5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb2xsaXNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlzaW9uID0gY29sbGlzaW9uc1tpXTtcclxuICAgICAgICBsb2coXHJcbiAgICAgICAgICAgIGBSZXNvbHZpbmcgY29sbGlzaW9uIGJldHdlZW4gJHtsLmlkfSBhdCBbJHtsLnh9LCR7bC55fV0gYW5kICR7XHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uaWRcclxuICAgICAgICAgICAgfSBhdCBbJHtjb2xsaXNpb24ueH0sJHtjb2xsaXNpb24ueX1dYCxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBTaG9ydCBjaXJjdWl0IHNvIHdlIGNhbid0IGluZmluaXRlIGxvb3BcclxuICAgICAgICBpZiAoY29sbGlzaW9uLm1vdmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG9uJ3QgbW92ZSBzdGF0aWMgaXRlbXMgLSB3ZSBoYXZlIHRvIG1vdmUgKnRoaXMqIGVsZW1lbnQgYXdheVxyXG4gICAgICAgIGlmIChjb2xsaXNpb24uc3RhdGljKSB7XHJcbiAgICAgICAgICAgIGxheW91dCA9IG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24oXHJcbiAgICAgICAgICAgICAgICBsYXlvdXQsXHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24sXHJcbiAgICAgICAgICAgICAgICBsLFxyXG4gICAgICAgICAgICAgICAgaXNVc2VyQWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgY29tcGFjdFR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb2xzLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxheW91dCA9IG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24oXHJcbiAgICAgICAgICAgICAgICBsYXlvdXQsXHJcbiAgICAgICAgICAgICAgICBsLFxyXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uLFxyXG4gICAgICAgICAgICAgICAgaXNVc2VyQWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgY29tcGFjdFR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb2xzLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5b3V0O1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB3aGVyZSB0aGUgbWFnaWMgbmVlZHMgdG8gaGFwcGVuIC0gZ2l2ZW4gYSBjb2xsaXNpb24sIG1vdmUgYW4gZWxlbWVudCBhd2F5IGZyb20gdGhlIGNvbGxpc2lvbi5cclxuICogV2UgYXR0ZW1wdCB0byBtb3ZlIGl0IHVwIGlmIHRoZXJlJ3Mgcm9vbSwgb3RoZXJ3aXNlIGl0IGdvZXMgYmVsb3cuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgICAgICAgICAgICBGdWxsIGxheW91dCB0byBtb2RpZnkuXHJcbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGNvbGxpZGVzV2l0aCBMYXlvdXQgaXRlbSB3ZSdyZSBjb2xsaWRpbmcgd2l0aC5cclxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gaXRlbVRvTW92ZSAgIExheW91dCBpdGVtIHdlJ3JlIG1vdmluZy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uKFxyXG4gICAgbGF5b3V0OiBMYXlvdXQsXHJcbiAgICBjb2xsaWRlc1dpdGg6IExheW91dEl0ZW0sXHJcbiAgICBpdGVtVG9Nb3ZlOiBMYXlvdXRJdGVtLFxyXG4gICAgaXNVc2VyQWN0aW9uOiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCxcclxuICAgIGNvbXBhY3RUeXBlOiBDb21wYWN0VHlwZSxcclxuICAgIGNvbHM6IG51bWJlcixcclxuKTogTGF5b3V0IHtcclxuICAgIGNvbnN0IGNvbXBhY3RIID0gY29tcGFjdFR5cGUgPT09ICdob3Jpem9udGFsJztcclxuICAgIC8vIENvbXBhY3QgdmVydGljYWxseSBpZiBub3Qgc2V0IHRvIGhvcml6b250YWxcclxuICAgIGNvbnN0IGNvbXBhY3RWID0gY29tcGFjdFR5cGUgIT09ICdob3Jpem9udGFsJztcclxuICAgIGNvbnN0IHByZXZlbnRDb2xsaXNpb24gPSBjb2xsaWRlc1dpdGguc3RhdGljOyAvLyB3ZSdyZSBhbHJlYWR5IGNvbGxpZGluZyAobm90IGZvciBzdGF0aWMgaXRlbXMpXHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGFib3ZlIHRoZSBjb2xsaXNpb24gdG8gcHV0IHRoaXMgZWxlbWVudCwgbW92ZSBpdCB0aGVyZS5cclxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiB0aGUgbWFpbiBjb2xsaXNpb24gYXMgdGhpcyBjYW4gZ2V0IGZ1bmt5IGluIGNhc2NhZGVzIGFuZCBjYXVzZVxyXG4gICAgLy8gdW53YW50ZWQgc3dhcHBpbmcgYmVoYXZpb3IuXHJcbiAgICBpZiAoaXNVc2VyQWN0aW9uKSB7XHJcbiAgICAgICAgLy8gUmVzZXQgaXNVc2VyQWN0aW9uIGZsYWcgYmVjYXVzZSB3ZSdyZSBub3QgaW4gdGhlIG1haW4gY29sbGlzaW9uIGFueW1vcmUuXHJcbiAgICAgICAgaXNVc2VyQWN0aW9uID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIE1ha2UgYSBtb2NrIGl0ZW0gc28gd2UgZG9uJ3QgbW9kaWZ5IHRoZSBpdGVtIGhlcmUsIG9ubHkgbW9kaWZ5IGluIG1vdmVFbGVtZW50LlxyXG4gICAgICAgIGNvbnN0IGZha2VJdGVtOiBMYXlvdXRJdGVtID0ge1xyXG4gICAgICAgICAgICB4OiBjb21wYWN0SFxyXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1heChjb2xsaWRlc1dpdGgueCAtIGl0ZW1Ub01vdmUudywgMClcclxuICAgICAgICAgICAgICAgIDogaXRlbVRvTW92ZS54LFxyXG4gICAgICAgICAgICB5OiBjb21wYWN0VlxyXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1heChjb2xsaWRlc1dpdGgueSAtIGl0ZW1Ub01vdmUuaCwgMClcclxuICAgICAgICAgICAgICAgIDogaXRlbVRvTW92ZS55LFxyXG4gICAgICAgICAgICB3OiBpdGVtVG9Nb3ZlLncsXHJcbiAgICAgICAgICAgIGg6IGl0ZW1Ub01vdmUuaCxcclxuICAgICAgICAgICAgaWQ6ICctMScsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gTm8gY29sbGlzaW9uPyBJZiBzbywgd2UgY2FuIGdvIHVwIHRoZXJlOyBvdGhlcndpc2UsIHdlJ2xsIGVuZCB1cCBtb3ZpbmcgZG93biBhcyBub3JtYWxcclxuICAgICAgICBpZiAoIWdldEZpcnN0Q29sbGlzaW9uKGxheW91dCwgZmFrZUl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGxvZyhcclxuICAgICAgICAgICAgICAgIGBEb2luZyByZXZlcnNlIGNvbGxpc2lvbiBvbiAke2l0ZW1Ub01vdmUuaWR9IHVwIHRvIFske1xyXG4gICAgICAgICAgICAgICAgICAgIGZha2VJdGVtLnhcclxuICAgICAgICAgICAgICAgIH0sJHtmYWtlSXRlbS55fV0uYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdmVFbGVtZW50KFxyXG4gICAgICAgICAgICAgICAgbGF5b3V0LFxyXG4gICAgICAgICAgICAgICAgaXRlbVRvTW92ZSxcclxuICAgICAgICAgICAgICAgIGNvbXBhY3RIID8gZmFrZUl0ZW0ueCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGNvbXBhY3RWID8gZmFrZUl0ZW0ueSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGlzVXNlckFjdGlvbixcclxuICAgICAgICAgICAgICAgIHByZXZlbnRDb2xsaXNpb24sXHJcbiAgICAgICAgICAgICAgICBjb21wYWN0VHlwZSxcclxuICAgICAgICAgICAgICAgIGNvbHMsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtb3ZlRWxlbWVudChcclxuICAgICAgICBsYXlvdXQsXHJcbiAgICAgICAgaXRlbVRvTW92ZSxcclxuICAgICAgICBjb21wYWN0SCA/IGl0ZW1Ub01vdmUueCArIDEgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgY29tcGFjdFYgPyBpdGVtVG9Nb3ZlLnkgKyAxIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGlzVXNlckFjdGlvbixcclxuICAgICAgICBwcmV2ZW50Q29sbGlzaW9uLFxyXG4gICAgICAgIGNvbXBhY3RUeXBlLFxyXG4gICAgICAgIGNvbHMsXHJcbiAgICApO1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIHRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBwZXJjZW50YWdlIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtICB7TnVtYmVyfSBudW0gQW55IG51bWJlclxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBUaGF0IG51bWJlciBhcyBhIHBlcmNlbnRhZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGVyYyhudW06IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gbnVtICogMTAwICsgJyUnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKHt0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHR9OiBQb3NpdGlvbik6IE9iamVjdCB7XHJcbiAgICAvLyBSZXBsYWNlIHVuaXRsZXNzIGl0ZW1zIHdpdGggcHhcclxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHtsZWZ0fXB4LCR7dG9wfXB4KWA7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlLFxyXG4gICAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNsYXRlLFxyXG4gICAgICAgIE1velRyYW5zZm9ybTogdHJhbnNsYXRlLFxyXG4gICAgICAgIG1zVHJhbnNmb3JtOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgT1RyYW5zZm9ybTogdHJhbnNsYXRlLFxyXG4gICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGAsXHJcbiAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFRvcExlZnQoe3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodH06IFBvc2l0aW9uKTogT2JqZWN0IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiBgJHt0b3B9cHhgLFxyXG4gICAgICAgIGxlZnQ6IGAke2xlZnR9cHhgLFxyXG4gICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGAsXHJcbiAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBsYXlvdXQgaXRlbXMgc29ydGVkIGZyb20gdG9wIGxlZnQgdG8gcmlnaHQgYW5kIGRvd24uXHJcbiAqXHJcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBsYXlvdXQgb2JqZWN0cy5cclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBMYXlvdXQsIHNvcnRlZCBzdGF0aWMgaXRlbXMgZmlyc3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29ydExheW91dEl0ZW1zKFxyXG4gICAgbGF5b3V0OiBMYXlvdXQsXHJcbiAgICBjb21wYWN0VHlwZTogQ29tcGFjdFR5cGUsXHJcbik6IExheW91dCB7XHJcbiAgICBpZiAoY29tcGFjdFR5cGUgPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgIHJldHVybiBzb3J0TGF5b3V0SXRlbXNCeUNvbFJvdyhsYXlvdXQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc29ydExheW91dEl0ZW1zQnlSb3dDb2wobGF5b3V0KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sKGxheW91dDogTGF5b3V0KTogTGF5b3V0IHtcclxuICAgIHJldHVybiAoW10gYXMgYW55W10pLmNvbmNhdChsYXlvdXQpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS55ID4gYi55IHx8IChhLnkgPT09IGIueSAmJiBhLnggPiBiLngpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYS55ID09PSBiLnkgJiYgYS54ID09PSBiLngpIHtcclxuICAgICAgICAgICAgLy8gV2l0aG91dCB0aGlzLCB3ZSBjYW4gZ2V0IGRpZmZlcmVudCBzb3J0IHJlc3VsdHMgaW4gSUUgdnMuIENocm9tZS9GRlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzb3J0TGF5b3V0SXRlbXNCeUNvbFJvdyhsYXlvdXQ6IExheW91dCk6IExheW91dCB7XHJcbiAgICByZXR1cm4gKFtdIGFzIGFueVtdKS5jb25jYXQobGF5b3V0KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEueCA+IGIueCB8fCAoYS54ID09PSBiLnggJiYgYS55ID4gYi55KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBhIGxheW91dC4gVGhyb3dzIGVycm9ycy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9ICBsYXlvdXQgICAgICAgIEFycmF5IG9mIGxheW91dCBpdGVtcy5cclxuICogQHBhcmFtICB7U3RyaW5nfSBbY29udGV4dE5hbWVdIENvbnRleHQgbmFtZSBmb3IgZXJyb3JzLlxyXG4gKiBAdGhyb3cgIHtFcnJvcn0gICAgICAgICAgICAgICAgVmFsaWRhdGlvbiBlcnJvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxheW91dChcclxuICAgIGxheW91dDogTGF5b3V0LFxyXG4gICAgY29udGV4dE5hbWU6IHN0cmluZyA9ICdMYXlvdXQnLFxyXG4pOiB2b2lkIHtcclxuICAgIGNvbnN0IHN1YlByb3BzID0gWyd4JywgJ3knLCAndycsICdoJ107XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGF5b3V0KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb250ZXh0TmFtZSArICcgbXVzdCBiZSBhbiBhcnJheSEnKTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gbGF5b3V0W2ldO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3ViUHJvcHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtW3N1YlByb3BzW2pdXSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAnUmVhY3RHcmlkTGF5b3V0OiAnICtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TmFtZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJ1snICtcclxuICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAnXS4nICtcclxuICAgICAgICAgICAgICAgICAgICBzdWJQcm9wc1tqXSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBtdXN0IGJlIGEgbnVtYmVyIScsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmlkICYmIHR5cGVvZiBpdGVtLmlkICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAnUmVhY3RHcmlkTGF5b3V0OiAnICtcclxuICAgICAgICAgICAgICAgIGNvbnRleHROYW1lICtcclxuICAgICAgICAgICAgICAgICdbJyArXHJcbiAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICddLmkgbXVzdCBiZSBhIHN0cmluZyEnLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5zdGF0aWMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaXRlbS5zdGF0aWMgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAnUmVhY3RHcmlkTGF5b3V0OiAnICtcclxuICAgICAgICAgICAgICAgIGNvbnRleHROYW1lICtcclxuICAgICAgICAgICAgICAgICdbJyArXHJcbiAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICddLnN0YXRpYyBtdXN0IGJlIGEgYm9vbGVhbiEnLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy8gRmxvdyBjYW4ndCByZWFsbHkgZmlndXJlIHRoaXMgb3V0LCBzbyB3ZSBqdXN0IHVzZSBPYmplY3RcclxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9CaW5kSGFuZGxlcnMoZWw6IE9iamVjdCwgZm5zOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcbiAgICBmbnMuZm9yRWFjaChrZXkgPT4gKGVsW2tleV0gPSBlbFtrZXldLmJpbmQoZWwpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XHJcbiAgICBpZiAoIURFQlVHKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xyXG4iXX0=