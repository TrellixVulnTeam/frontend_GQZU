import { compact, getFirstCollision, moveElement } from './react-grid-layout.utils';
import { ktdPointerClientX, ktdPointerClientY } from './pointer.utils';
/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */
export function ktdTrackById(index, item) {
    return item.id;
}
/**
 * Call react-grid-layout utils 'compact()' function and return the compacted layout.
 * @param layout to be compacted.
 * @param compactType, type of compaction.
 * @param cols, number of columns of the grid.
 */
export function ktdGridCompact(layout, compactType, cols) {
    return compact(layout, compactType, cols)
        // Prune react-grid-layout compact extra properties.
        .map(item => ({ id: item.id, x: item.x, y: item.y, w: item.w, h: item.h, minW: item.minW, minH: item.minH, maxW: item.maxW, maxH: item.maxH }));
}
function screenXPosToGridValue(screenXPos, cols, width) {
    return Math.round((screenXPos * cols) / width);
}
function screenYPosToGridValue(screenYPos, rowHeight, height) {
    return Math.round(screenYPos / rowHeight);
}
/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */
export function ktdGetGridLayoutDiff(gridLayoutA, gridLayoutB) {
    const diff = {};
    gridLayoutA.forEach(itemA => {
        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);
        if (itemB != null) {
            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;
            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;
            const change = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;
            if (change) {
                diff[itemB.id] = { change };
            }
        }
    });
    return diff;
}
/**
 * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position
 * @param gridItem grid item that is been dragged
 * @param config current grid configuration
 * @param compactionType type of compaction that will be performed
 * @param draggingData contains all the information about the drag
 */
export function ktdGridItemDragging(gridItem, config, compactionType, draggingData) {
    const { pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference } = draggingData;
    const gridItemId = gridItem.id;
    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);
    const clientStartX = ktdPointerClientX(pointerDownEvent);
    const clientStartY = ktdPointerClientY(pointerDownEvent);
    const clientX = ktdPointerClientX(pointerDragEvent);
    const clientY = ktdPointerClientY(pointerDragEvent);
    const offsetX = clientStartX - dragElemClientRect.left;
    const offsetY = clientStartY - dragElemClientRect.top;
    // Grid element positions taking into account the possible scroll total difference from the beginning.
    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;
    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;
    // Calculate position relative to the grid element.
    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;
    const gridRelYPos = clientY - gridElementTopPosition - offsetY;
    // Get layout item position
    const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), { x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width), y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height) });
    // Correct the values if they overflow, since 'moveElement' function doesn't do it
    layoutItem.x = Math.max(0, layoutItem.x);
    layoutItem.y = Math.max(0, layoutItem.y);
    if (layoutItem.x + layoutItem.w > config.cols) {
        layoutItem.x = Math.max(0, config.cols - layoutItem.w);
    }
    // Parse to LayoutItem array data in order to use 'react.grid-layout' utils
    const layoutItems = config.layout;
    const draggedLayoutItem = layoutItems.find(item => item.id === gridItemId);
    let newLayoutItems = moveElement(layoutItems, draggedLayoutItem, layoutItem.x, layoutItem.y, true, config.preventCollision, compactionType, config.cols);
    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);
    return {
        layout: newLayoutItems,
        draggedItemPos: {
            top: gridRelYPos,
            left: gridRelXPos,
            width: dragElemClientRect.width,
            height: dragElemClientRect.height,
        }
    };
}
/**
 * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position
 * @param gridItem grid item that is been dragged
 * @param config current grid configuration
 * @param compactionType type of compaction that will be performed
 * @param draggingData contains all the information about the drag
 */
export function ktdGridItemResizing(gridItem, config, compactionType, draggingData) {
    var _a, _b, _c, _d;
    const { pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference } = draggingData;
    const gridItemId = gridItem.id;
    const clientStartX = ktdPointerClientX(pointerDownEvent);
    const clientStartY = ktdPointerClientY(pointerDownEvent);
    const clientX = ktdPointerClientX(pointerDragEvent);
    const clientY = ktdPointerClientY(pointerDragEvent);
    // Get the difference between the mouseDown and the position 'right' of the resize element.
    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);
    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);
    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);
    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);
    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);
    // Get layout item grid position
    const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), { w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width), h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height) });
    layoutItem.w = limitNumberWithinRange(layoutItem.w, (_a = gridItem.minW) !== null && _a !== void 0 ? _a : layoutItem.minW, (_b = gridItem.maxW) !== null && _b !== void 0 ? _b : layoutItem.maxW);
    layoutItem.h = limitNumberWithinRange(layoutItem.h, (_c = gridItem.minH) !== null && _c !== void 0 ? _c : layoutItem.minH, (_d = gridItem.maxH) !== null && _d !== void 0 ? _d : layoutItem.maxH);
    if (layoutItem.x + layoutItem.w > config.cols) {
        layoutItem.w = Math.max(1, config.cols - layoutItem.x);
    }
    if (config.preventCollision) {
        const maxW = layoutItem.w;
        const maxH = layoutItem.h;
        let colliding = hasCollision(config.layout, layoutItem);
        let shrunkDimension;
        while (colliding) {
            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);
            layoutItem[shrunkDimension]--;
            colliding = hasCollision(config.layout, layoutItem);
        }
        if (shrunkDimension === 'w') {
            layoutItem.h = maxH;
            colliding = hasCollision(config.layout, layoutItem);
            while (colliding) {
                layoutItem.h--;
                colliding = hasCollision(config.layout, layoutItem);
            }
        }
        if (shrunkDimension === 'h') {
            layoutItem.w = maxW;
            colliding = hasCollision(config.layout, layoutItem);
            while (colliding) {
                layoutItem.w--;
                colliding = hasCollision(config.layout, layoutItem);
            }
        }
    }
    const newLayoutItems = config.layout.map((item) => {
        return item.id === gridItemId ? layoutItem : item;
    });
    return {
        layout: compact(newLayoutItems, compactionType, config.cols),
        draggedItemPos: {
            top: dragElemClientRect.top - gridElemClientRect.top,
            left: dragElemClientRect.left - gridElemClientRect.left,
            width,
            height,
        }
    };
}
function hasCollision(layout, layoutItem) {
    return !!getFirstCollision(layout, layoutItem);
}
function getDimensionToShrink(layoutItem, lastShrunk) {
    if (layoutItem.h <= 1) {
        return 'w';
    }
    if (layoutItem.w <= 1) {
        return 'h';
    }
    return lastShrunk === 'w' ? 'h' : 'w';
}
/**
 * Given the current number and min/max values, returns the number within the range
 * @param number can be any numeric value
 * @param min minimum value of range
 * @param max maximum value of range
 */
function limitNumberWithinRange(num, min = 1, max = Infinity) {
    return Math.min(Math.max(num, min < 1 ? 1 : min), max);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC51dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItZ3JpZC1sYXlvdXQvc3JjL2xpYi91dGlscy9ncmlkLnV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQWUsaUJBQWlCLEVBQXNCLFdBQVcsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRXJILE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBSXZFLDJIQUEySDtBQUMzSCxNQUFNLFVBQVUsWUFBWSxDQUFDLEtBQWEsRUFBRSxJQUFrQjtJQUMxRCxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUM7QUFDbkIsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGNBQWMsQ0FBQyxNQUFxQixFQUFFLFdBQStCLEVBQUUsSUFBWTtJQUMvRixPQUFPLE9BQU8sQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQztRQUNyQyxvREFBb0Q7U0FDbkQsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3hKLENBQUM7QUFFRCxTQUFTLHFCQUFxQixDQUFDLFVBQWtCLEVBQUUsSUFBWSxFQUFFLEtBQWE7SUFDMUUsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQ25ELENBQUM7QUFFRCxTQUFTLHFCQUFxQixDQUFDLFVBQWtCLEVBQUUsU0FBaUIsRUFBRSxNQUFjO0lBQ2hGLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDLENBQUM7QUFDOUMsQ0FBQztBQUVELHdJQUF3STtBQUN4SSxNQUFNLFVBQVUsb0JBQW9CLENBQUMsV0FBZ0MsRUFBRSxXQUFnQztJQUNuRyxNQUFNLElBQUksR0FBZ0UsRUFBRSxDQUFDO0lBRTdFLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDeEIsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pFLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtZQUNmLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDOUQsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQztZQUMvRCxNQUFNLE1BQU0sR0FBNEMsVUFBVSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUN2SixJQUFJLE1BQU0sRUFBRTtnQkFDUixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUMsTUFBTSxFQUFDLENBQUM7YUFDN0I7U0FDSjtJQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxJQUFJLENBQUM7QUFDaEIsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxRQUE4QixFQUFFLE1BQWtCLEVBQUUsY0FBMkIsRUFBRSxZQUE2QjtJQUM5SSxNQUFNLEVBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUMsR0FBRyxZQUFZLENBQUM7SUFFcEgsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQztJQUUvQixNQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVLENBQUUsQ0FBQztJQUVqRixNQUFNLFlBQVksR0FBRyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3pELE1BQU0sWUFBWSxHQUFHLGlCQUFpQixDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDekQsTUFBTSxPQUFPLEdBQUcsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUNwRCxNQUFNLE9BQU8sR0FBRyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRXBELE1BQU0sT0FBTyxHQUFHLFlBQVksR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUM7SUFDdkQsTUFBTSxPQUFPLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUV0RCxzR0FBc0c7SUFDdEcsTUFBTSx1QkFBdUIsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDO0lBQ2hGLE1BQU0sc0JBQXNCLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxHQUFHLGdCQUFnQixDQUFDLEdBQUcsQ0FBQztJQUU3RSxtREFBbUQ7SUFDbkQsTUFBTSxXQUFXLEdBQUcsT0FBTyxHQUFHLHVCQUF1QixHQUFHLE9BQU8sQ0FBQztJQUNoRSxNQUFNLFdBQVcsR0FBRyxPQUFPLEdBQUcsc0JBQXNCLEdBQUcsT0FBTyxDQUFDO0lBRS9ELDJCQUEyQjtJQUMzQixNQUFNLFVBQVUsbUNBQ1Qsb0JBQW9CLEtBQ3ZCLENBQUMsRUFBRSxxQkFBcUIsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsRUFDNUUsQ0FBQyxFQUFFLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsU0FBUyxFQUFFLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxHQUNyRixDQUFDO0lBRUYsa0ZBQWtGO0lBQ2xGLFVBQVUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUU7UUFDM0MsVUFBVSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMxRDtJQUVELDJFQUEyRTtJQUMzRSxNQUFNLFdBQVcsR0FBaUIsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUNoRCxNQUFNLGlCQUFpQixHQUFlLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLFVBQVUsQ0FBRSxDQUFDO0lBRXhGLElBQUksY0FBYyxHQUFpQixXQUFXLENBQzFDLFdBQVcsRUFDWCxpQkFBaUIsRUFDakIsVUFBVSxDQUFDLENBQUMsRUFDWixVQUFVLENBQUMsQ0FBQyxFQUNaLElBQUksRUFDSixNQUFNLENBQUMsZ0JBQWdCLEVBQ3ZCLGNBQWMsRUFDZCxNQUFNLENBQUMsSUFBSSxDQUNkLENBQUM7SUFFRixjQUFjLEdBQUcsT0FBTyxDQUFDLGNBQWMsRUFBRSxjQUFjLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXRFLE9BQU87UUFDSCxNQUFNLEVBQUUsY0FBYztRQUN0QixjQUFjLEVBQUU7WUFDWixHQUFHLEVBQUUsV0FBVztZQUNoQixJQUFJLEVBQUUsV0FBVztZQUNqQixLQUFLLEVBQUUsa0JBQWtCLENBQUMsS0FBSztZQUMvQixNQUFNLEVBQUUsa0JBQWtCLENBQUMsTUFBTTtTQUNwQztLQUNKLENBQUM7QUFDTixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLG1CQUFtQixDQUFDLFFBQThCLEVBQUUsTUFBa0IsRUFBRSxjQUEyQixFQUFFLFlBQTZCOztJQUM5SSxNQUFNLEVBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUMsR0FBRyxZQUFZLENBQUM7SUFDcEgsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQztJQUUvQixNQUFNLFlBQVksR0FBRyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3pELE1BQU0sWUFBWSxHQUFHLGlCQUFpQixDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDekQsTUFBTSxPQUFPLEdBQUcsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUNwRCxNQUFNLE9BQU8sR0FBRyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRXBELDJGQUEyRjtJQUMzRixNQUFNLGlCQUFpQixHQUFHLGtCQUFrQixDQUFDLEtBQUssR0FBRyxDQUFDLFlBQVksR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5RixNQUFNLGlCQUFpQixHQUFHLGtCQUFrQixDQUFDLE1BQU0sR0FBRyxDQUFDLFlBQVksR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUU5RixNQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVLENBQUUsQ0FBQztJQUNqRixNQUFNLEtBQUssR0FBRyxPQUFPLEdBQUcsaUJBQWlCLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUYsTUFBTSxNQUFNLEdBQUcsT0FBTyxHQUFHLGlCQUFpQixHQUFHLENBQUMsa0JBQWtCLENBQUMsR0FBRyxHQUFHLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRzdGLGdDQUFnQztJQUNoQyxNQUFNLFVBQVUsbUNBQ1Qsb0JBQW9CLEtBQ3ZCLENBQUMsRUFBRSxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsRUFDdEUsQ0FBQyxFQUFFLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsU0FBUyxFQUFFLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxHQUNoRixDQUFDO0lBRUYsVUFBVSxDQUFDLENBQUMsR0FBRyxzQkFBc0IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLE1BQUEsUUFBUSxDQUFDLElBQUksbUNBQUksVUFBVSxDQUFDLElBQUksRUFBRSxNQUFBLFFBQVEsQ0FBQyxJQUFJLG1DQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4SCxVQUFVLENBQUMsQ0FBQyxHQUFHLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsTUFBQSxRQUFRLENBQUMsSUFBSSxtQ0FBSSxVQUFVLENBQUMsSUFBSSxFQUFFLE1BQUEsUUFBUSxDQUFDLElBQUksbUNBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXhILElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUU7UUFDM0MsVUFBVSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMxRDtJQUVELElBQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFO1FBQ3pCLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDMUIsTUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUUxQixJQUFJLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUN4RCxJQUFJLGVBQXNDLENBQUM7UUFFM0MsT0FBTyxTQUFTLEVBQUU7WUFDZCxlQUFlLEdBQUcsb0JBQW9CLENBQUMsVUFBVSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1lBQ3BFLFVBQVUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDO1lBQzlCLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztTQUN2RDtRQUVELElBQUksZUFBZSxLQUFLLEdBQUcsRUFBRTtZQUN6QixVQUFVLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUVwQixTQUFTLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDcEQsT0FBTyxTQUFTLEVBQUU7Z0JBQ2QsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNmLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQzthQUN2RDtTQUNKO1FBQ0QsSUFBSSxlQUFlLEtBQUssR0FBRyxFQUFFO1lBQ3pCLFVBQVUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBRXBCLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztZQUNwRCxPQUFPLFNBQVMsRUFBRTtnQkFDZCxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQ2YsU0FBUyxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQ3ZEO1NBQ0o7S0FFSjtJQUVELE1BQU0sY0FBYyxHQUFpQixNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQzVELE9BQU8sSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3RELENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTztRQUNILE1BQU0sRUFBRSxPQUFPLENBQUMsY0FBYyxFQUFFLGNBQWMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQzVELGNBQWMsRUFBRTtZQUNaLEdBQUcsRUFBRSxrQkFBa0IsQ0FBQyxHQUFHLEdBQUcsa0JBQWtCLENBQUMsR0FBRztZQUNwRCxJQUFJLEVBQUUsa0JBQWtCLENBQUMsSUFBSSxHQUFHLGtCQUFrQixDQUFDLElBQUk7WUFDdkQsS0FBSztZQUNMLE1BQU07U0FDVDtLQUNKLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxZQUFZLENBQUMsTUFBYyxFQUFFLFVBQXNCO0lBQ3hELE9BQU8sQ0FBQyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNuRCxDQUFDO0FBRUQsU0FBUyxvQkFBb0IsQ0FBQyxVQUFVLEVBQUUsVUFBVTtJQUNoRCxJQUFJLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ25CLE9BQU8sR0FBRyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ25CLE9BQU8sR0FBRyxDQUFDO0tBQ2Q7SUFFRCxPQUFPLFVBQVUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzFDLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQVMsc0JBQXNCLENBQUMsR0FBVyxFQUFFLE1BQWMsQ0FBQyxFQUFFLE1BQWMsUUFBUTtJQUNoRixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMzRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tcGFjdCwgQ29tcGFjdFR5cGUsIGdldEZpcnN0Q29sbGlzaW9uLCBMYXlvdXQsIExheW91dEl0ZW0sIG1vdmVFbGVtZW50IH0gZnJvbSAnLi9yZWFjdC1ncmlkLWxheW91dC51dGlscyc7XHJcbmltcG9ydCB7IEt0ZERyYWdnaW5nRGF0YSwgS3RkR3JpZENmZywgS3RkR3JpZENvbXBhY3RUeXBlLCBLdGRHcmlkSXRlbVJlY3QsIEt0ZEdyaWRMYXlvdXQsIEt0ZEdyaWRMYXlvdXRJdGVtIH0gZnJvbSAnLi4vZ3JpZC5kZWZpbml0aW9ucyc7XHJcbmltcG9ydCB7IGt0ZFBvaW50ZXJDbGllbnRYLCBrdGRQb2ludGVyQ2xpZW50WSB9IGZyb20gJy4vcG9pbnRlci51dGlscyc7XHJcbmltcG9ydCB7IEt0ZERpY3Rpb25hcnkgfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcbmltcG9ydCB7IEt0ZEdyaWRJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi4vZ3JpZC1pdGVtL2dyaWQtaXRlbS5jb21wb25lbnQnO1xyXG5cclxuLyoqIFRyYWNrcyBpdGVtcyBieSBpZC4gVGhpcyBmdW5jdGlvbiBpcyBtZWFuIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgbmdGb3IgdGhhdCByZW5kZXJzIHRoZSAna3RkLWdyaWQtaXRlbXMnICovXHJcbmV4cG9ydCBmdW5jdGlvbiBrdGRUcmFja0J5SWQoaW5kZXg6IG51bWJlciwgaXRlbToge2lkOiBzdHJpbmd9KSB7XHJcbiAgICByZXR1cm4gaXRlbS5pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGwgcmVhY3QtZ3JpZC1sYXlvdXQgdXRpbHMgJ2NvbXBhY3QoKScgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgY29tcGFjdGVkIGxheW91dC5cclxuICogQHBhcmFtIGxheW91dCB0byBiZSBjb21wYWN0ZWQuXHJcbiAqIEBwYXJhbSBjb21wYWN0VHlwZSwgdHlwZSBvZiBjb21wYWN0aW9uLlxyXG4gKiBAcGFyYW0gY29scywgbnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIGdyaWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24ga3RkR3JpZENvbXBhY3QobGF5b3V0OiBLdGRHcmlkTGF5b3V0LCBjb21wYWN0VHlwZTogS3RkR3JpZENvbXBhY3RUeXBlLCBjb2xzOiBudW1iZXIpOiBLdGRHcmlkTGF5b3V0IHtcclxuICAgIHJldHVybiBjb21wYWN0KGxheW91dCwgY29tcGFjdFR5cGUsIGNvbHMpXHJcbiAgICAgICAgLy8gUHJ1bmUgcmVhY3QtZ3JpZC1sYXlvdXQgY29tcGFjdCBleHRyYSBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIC5tYXAoaXRlbSA9PiAoeyBpZDogaXRlbS5pZCwgeDogaXRlbS54LCB5OiBpdGVtLnksIHc6IGl0ZW0udywgaDogaXRlbS5oLCBtaW5XOiBpdGVtLm1pblcsIG1pbkg6IGl0ZW0ubWluSCwgbWF4VzogaXRlbS5tYXhXLCBtYXhIOiBpdGVtLm1heEggfSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzY3JlZW5YUG9zVG9HcmlkVmFsdWUoc2NyZWVuWFBvczogbnVtYmVyLCBjb2xzOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKHNjcmVlblhQb3MgKiBjb2xzKSAvIHdpZHRoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2NyZWVuWVBvc1RvR3JpZFZhbHVlKHNjcmVlbllQb3M6IG51bWJlciwgcm93SGVpZ2h0OiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKHNjcmVlbllQb3MgLyByb3dIZWlnaHQpO1xyXG59XHJcblxyXG4vKiogUmV0dXJucyBhIERpY3Rpb25hcnkgd2hlcmUgdGhlIGtleSBpcyB0aGUgaWQgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgY2hhbmdlIGFwcGxpZWQgdG8gdGhhdCBpdGVtLiBJZiBubyBjaGFuZ2VzIERpY3Rpb25hcnkgaXMgZW1wdHkuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBrdGRHZXRHcmlkTGF5b3V0RGlmZihncmlkTGF5b3V0QTogS3RkR3JpZExheW91dEl0ZW1bXSwgZ3JpZExheW91dEI6IEt0ZEdyaWRMYXlvdXRJdGVtW10pOiBLdGREaWN0aW9uYXJ5PHsgY2hhbmdlOiAnbW92ZScgfCAncmVzaXplJyB8ICdtb3ZlcmVzaXplJyB9PiB7XHJcbiAgICBjb25zdCBkaWZmOiBLdGREaWN0aW9uYXJ5PHsgY2hhbmdlOiAnbW92ZScgfCAncmVzaXplJyB8ICdtb3ZlcmVzaXplJyB9PiA9IHt9O1xyXG5cclxuICAgIGdyaWRMYXlvdXRBLmZvckVhY2goaXRlbUEgPT4ge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1CID0gZ3JpZExheW91dEIuZmluZChfaXRlbUIgPT4gX2l0ZW1CLmlkID09PSBpdGVtQS5pZCk7XHJcbiAgICAgICAgaWYgKGl0ZW1CICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9zQ2hhbmdlZCA9IGl0ZW1BLnggIT09IGl0ZW1CLnggfHwgaXRlbUEueSAhPT0gaXRlbUIueTtcclxuICAgICAgICAgICAgY29uc3Qgc2l6ZUNoYW5nZWQgPSBpdGVtQS53ICE9PSBpdGVtQi53IHx8IGl0ZW1BLmggIT09IGl0ZW1CLmg7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZTogJ21vdmUnIHwgJ3Jlc2l6ZScgfCAnbW92ZXJlc2l6ZScgfCBudWxsID0gcG9zQ2hhbmdlZCAmJiBzaXplQ2hhbmdlZCA/ICdtb3ZlcmVzaXplJyA6IHBvc0NoYW5nZWQgPyAnbW92ZScgOiBzaXplQ2hhbmdlZCA/ICdyZXNpemUnIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgZGlmZltpdGVtQi5pZF0gPSB7Y2hhbmdlfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRpZmY7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0aGUgZ3JpZCBjb25maWcgJiBsYXlvdXQgZGF0YSBhbmQgdGhlIGN1cnJlbnQgZHJhZyBwb3NpdGlvbiAmIGluZm9ybWF0aW9uLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGxheW91dCBhbmQgZHJhZyBpdGVtIHBvc2l0aW9uXHJcbiAqIEBwYXJhbSBncmlkSXRlbSBncmlkIGl0ZW0gdGhhdCBpcyBiZWVuIGRyYWdnZWRcclxuICogQHBhcmFtIGNvbmZpZyBjdXJyZW50IGdyaWQgY29uZmlndXJhdGlvblxyXG4gKiBAcGFyYW0gY29tcGFjdGlvblR5cGUgdHlwZSBvZiBjb21wYWN0aW9uIHRoYXQgd2lsbCBiZSBwZXJmb3JtZWRcclxuICogQHBhcmFtIGRyYWdnaW5nRGF0YSBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkcmFnXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24ga3RkR3JpZEl0ZW1EcmFnZ2luZyhncmlkSXRlbTogS3RkR3JpZEl0ZW1Db21wb25lbnQsIGNvbmZpZzogS3RkR3JpZENmZywgY29tcGFjdGlvblR5cGU6IENvbXBhY3RUeXBlLCBkcmFnZ2luZ0RhdGE6IEt0ZERyYWdnaW5nRGF0YSk6IHsgbGF5b3V0OiBLdGRHcmlkTGF5b3V0SXRlbVtdOyBkcmFnZ2VkSXRlbVBvczogS3RkR3JpZEl0ZW1SZWN0IH0ge1xyXG4gICAgY29uc3Qge3BvaW50ZXJEb3duRXZlbnQsIHBvaW50ZXJEcmFnRXZlbnQsIGdyaWRFbGVtQ2xpZW50UmVjdCwgZHJhZ0VsZW1DbGllbnRSZWN0LCBzY3JvbGxEaWZmZXJlbmNlfSA9IGRyYWdnaW5nRGF0YTtcclxuXHJcbiAgICBjb25zdCBncmlkSXRlbUlkID0gZ3JpZEl0ZW0uaWQ7XHJcblxyXG4gICAgY29uc3QgZHJhZ2dpbmdFbGVtUHJldkl0ZW0gPSBjb25maWcubGF5b3V0LmZpbmQoaXRlbSA9PiBpdGVtLmlkID09PSBncmlkSXRlbUlkKSE7XHJcblxyXG4gICAgY29uc3QgY2xpZW50U3RhcnRYID0ga3RkUG9pbnRlckNsaWVudFgocG9pbnRlckRvd25FdmVudCk7XHJcbiAgICBjb25zdCBjbGllbnRTdGFydFkgPSBrdGRQb2ludGVyQ2xpZW50WShwb2ludGVyRG93bkV2ZW50KTtcclxuICAgIGNvbnN0IGNsaWVudFggPSBrdGRQb2ludGVyQ2xpZW50WChwb2ludGVyRHJhZ0V2ZW50KTtcclxuICAgIGNvbnN0IGNsaWVudFkgPSBrdGRQb2ludGVyQ2xpZW50WShwb2ludGVyRHJhZ0V2ZW50KTtcclxuXHJcbiAgICBjb25zdCBvZmZzZXRYID0gY2xpZW50U3RhcnRYIC0gZHJhZ0VsZW1DbGllbnRSZWN0LmxlZnQ7XHJcbiAgICBjb25zdCBvZmZzZXRZID0gY2xpZW50U3RhcnRZIC0gZHJhZ0VsZW1DbGllbnRSZWN0LnRvcDtcclxuXHJcbiAgICAvLyBHcmlkIGVsZW1lbnQgcG9zaXRpb25zIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHBvc3NpYmxlIHNjcm9sbCB0b3RhbCBkaWZmZXJlbmNlIGZyb20gdGhlIGJlZ2lubmluZy5cclxuICAgIGNvbnN0IGdyaWRFbGVtZW50TGVmdFBvc2l0aW9uID0gZ3JpZEVsZW1DbGllbnRSZWN0LmxlZnQgKyBzY3JvbGxEaWZmZXJlbmNlLmxlZnQ7XHJcbiAgICBjb25zdCBncmlkRWxlbWVudFRvcFBvc2l0aW9uID0gZ3JpZEVsZW1DbGllbnRSZWN0LnRvcCArIHNjcm9sbERpZmZlcmVuY2UudG9wO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgZ3JpZCBlbGVtZW50LlxyXG4gICAgY29uc3QgZ3JpZFJlbFhQb3MgPSBjbGllbnRYIC0gZ3JpZEVsZW1lbnRMZWZ0UG9zaXRpb24gLSBvZmZzZXRYO1xyXG4gICAgY29uc3QgZ3JpZFJlbFlQb3MgPSBjbGllbnRZIC0gZ3JpZEVsZW1lbnRUb3BQb3NpdGlvbiAtIG9mZnNldFk7XHJcblxyXG4gICAgLy8gR2V0IGxheW91dCBpdGVtIHBvc2l0aW9uXHJcbiAgICBjb25zdCBsYXlvdXRJdGVtOiBLdGRHcmlkTGF5b3V0SXRlbSA9IHtcclxuICAgICAgICAuLi5kcmFnZ2luZ0VsZW1QcmV2SXRlbSxcclxuICAgICAgICB4OiBzY3JlZW5YUG9zVG9HcmlkVmFsdWUoZ3JpZFJlbFhQb3MsIGNvbmZpZy5jb2xzLCBncmlkRWxlbUNsaWVudFJlY3Qud2lkdGgpLFxyXG4gICAgICAgIHk6IHNjcmVlbllQb3NUb0dyaWRWYWx1ZShncmlkUmVsWVBvcywgY29uZmlnLnJvd0hlaWdodCwgZ3JpZEVsZW1DbGllbnRSZWN0LmhlaWdodClcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ29ycmVjdCB0aGUgdmFsdWVzIGlmIHRoZXkgb3ZlcmZsb3csIHNpbmNlICdtb3ZlRWxlbWVudCcgZnVuY3Rpb24gZG9lc24ndCBkbyBpdFxyXG4gICAgbGF5b3V0SXRlbS54ID0gTWF0aC5tYXgoMCwgbGF5b3V0SXRlbS54KTtcclxuICAgIGxheW91dEl0ZW0ueSA9IE1hdGgubWF4KDAsIGxheW91dEl0ZW0ueSk7XHJcbiAgICBpZiAobGF5b3V0SXRlbS54ICsgbGF5b3V0SXRlbS53ID4gY29uZmlnLmNvbHMpIHtcclxuICAgICAgICBsYXlvdXRJdGVtLnggPSBNYXRoLm1heCgwLCBjb25maWcuY29scyAtIGxheW91dEl0ZW0udyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2UgdG8gTGF5b3V0SXRlbSBhcnJheSBkYXRhIGluIG9yZGVyIHRvIHVzZSAncmVhY3QuZ3JpZC1sYXlvdXQnIHV0aWxzXHJcbiAgICBjb25zdCBsYXlvdXRJdGVtczogTGF5b3V0SXRlbVtdID0gY29uZmlnLmxheW91dDtcclxuICAgIGNvbnN0IGRyYWdnZWRMYXlvdXRJdGVtOiBMYXlvdXRJdGVtID0gbGF5b3V0SXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IGdyaWRJdGVtSWQpITtcclxuXHJcbiAgICBsZXQgbmV3TGF5b3V0SXRlbXM6IExheW91dEl0ZW1bXSA9IG1vdmVFbGVtZW50KFxyXG4gICAgICAgIGxheW91dEl0ZW1zLFxyXG4gICAgICAgIGRyYWdnZWRMYXlvdXRJdGVtLFxyXG4gICAgICAgIGxheW91dEl0ZW0ueCxcclxuICAgICAgICBsYXlvdXRJdGVtLnksXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICBjb25maWcucHJldmVudENvbGxpc2lvbixcclxuICAgICAgICBjb21wYWN0aW9uVHlwZSxcclxuICAgICAgICBjb25maWcuY29sc1xyXG4gICAgKTtcclxuXHJcbiAgICBuZXdMYXlvdXRJdGVtcyA9IGNvbXBhY3QobmV3TGF5b3V0SXRlbXMsIGNvbXBhY3Rpb25UeXBlLCBjb25maWcuY29scyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dEl0ZW1zLFxyXG4gICAgICAgIGRyYWdnZWRJdGVtUG9zOiB7XHJcbiAgICAgICAgICAgIHRvcDogZ3JpZFJlbFlQb3MsXHJcbiAgICAgICAgICAgIGxlZnQ6IGdyaWRSZWxYUG9zLFxyXG4gICAgICAgICAgICB3aWR0aDogZHJhZ0VsZW1DbGllbnRSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGRyYWdFbGVtQ2xpZW50UmVjdC5oZWlnaHQsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHRoZSBncmlkIGNvbmZpZyAmIGxheW91dCBkYXRhIGFuZCB0aGUgY3VycmVudCBkcmFnIHBvc2l0aW9uICYgaW5mb3JtYXRpb24sIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgbGF5b3V0IGFuZCBkcmFnIGl0ZW0gcG9zaXRpb25cclxuICogQHBhcmFtIGdyaWRJdGVtIGdyaWQgaXRlbSB0aGF0IGlzIGJlZW4gZHJhZ2dlZFxyXG4gKiBAcGFyYW0gY29uZmlnIGN1cnJlbnQgZ3JpZCBjb25maWd1cmF0aW9uXHJcbiAqIEBwYXJhbSBjb21wYWN0aW9uVHlwZSB0eXBlIG9mIGNvbXBhY3Rpb24gdGhhdCB3aWxsIGJlIHBlcmZvcm1lZFxyXG4gKiBAcGFyYW0gZHJhZ2dpbmdEYXRhIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRyYWdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBrdGRHcmlkSXRlbVJlc2l6aW5nKGdyaWRJdGVtOiBLdGRHcmlkSXRlbUNvbXBvbmVudCwgY29uZmlnOiBLdGRHcmlkQ2ZnLCBjb21wYWN0aW9uVHlwZTogQ29tcGFjdFR5cGUsIGRyYWdnaW5nRGF0YTogS3RkRHJhZ2dpbmdEYXRhKTogeyBsYXlvdXQ6IEt0ZEdyaWRMYXlvdXRJdGVtW107IGRyYWdnZWRJdGVtUG9zOiBLdGRHcmlkSXRlbVJlY3QgfSB7XHJcbiAgICBjb25zdCB7cG9pbnRlckRvd25FdmVudCwgcG9pbnRlckRyYWdFdmVudCwgZ3JpZEVsZW1DbGllbnRSZWN0LCBkcmFnRWxlbUNsaWVudFJlY3QsIHNjcm9sbERpZmZlcmVuY2V9ID0gZHJhZ2dpbmdEYXRhO1xyXG4gICAgY29uc3QgZ3JpZEl0ZW1JZCA9IGdyaWRJdGVtLmlkO1xyXG5cclxuICAgIGNvbnN0IGNsaWVudFN0YXJ0WCA9IGt0ZFBvaW50ZXJDbGllbnRYKHBvaW50ZXJEb3duRXZlbnQpO1xyXG4gICAgY29uc3QgY2xpZW50U3RhcnRZID0ga3RkUG9pbnRlckNsaWVudFkocG9pbnRlckRvd25FdmVudCk7XHJcbiAgICBjb25zdCBjbGllbnRYID0ga3RkUG9pbnRlckNsaWVudFgocG9pbnRlckRyYWdFdmVudCk7XHJcbiAgICBjb25zdCBjbGllbnRZID0ga3RkUG9pbnRlckNsaWVudFkocG9pbnRlckRyYWdFdmVudCk7XHJcblxyXG4gICAgLy8gR2V0IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG1vdXNlRG93biBhbmQgdGhlIHBvc2l0aW9uICdyaWdodCcgb2YgdGhlIHJlc2l6ZSBlbGVtZW50LlxyXG4gICAgY29uc3QgcmVzaXplRWxlbU9mZnNldFggPSBkcmFnRWxlbUNsaWVudFJlY3Qud2lkdGggLSAoY2xpZW50U3RhcnRYIC0gZHJhZ0VsZW1DbGllbnRSZWN0LmxlZnQpO1xyXG4gICAgY29uc3QgcmVzaXplRWxlbU9mZnNldFkgPSBkcmFnRWxlbUNsaWVudFJlY3QuaGVpZ2h0IC0gKGNsaWVudFN0YXJ0WSAtIGRyYWdFbGVtQ2xpZW50UmVjdC50b3ApO1xyXG5cclxuICAgIGNvbnN0IGRyYWdnaW5nRWxlbVByZXZJdGVtID0gY29uZmlnLmxheW91dC5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gZ3JpZEl0ZW1JZCkhO1xyXG4gICAgY29uc3Qgd2lkdGggPSBjbGllbnRYICsgcmVzaXplRWxlbU9mZnNldFggLSAoZHJhZ0VsZW1DbGllbnRSZWN0LmxlZnQgKyBzY3JvbGxEaWZmZXJlbmNlLmxlZnQpO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gY2xpZW50WSArIHJlc2l6ZUVsZW1PZmZzZXRZIC0gKGRyYWdFbGVtQ2xpZW50UmVjdC50b3AgKyBzY3JvbGxEaWZmZXJlbmNlLnRvcCk7XHJcblxyXG5cclxuICAgIC8vIEdldCBsYXlvdXQgaXRlbSBncmlkIHBvc2l0aW9uXHJcbiAgICBjb25zdCBsYXlvdXRJdGVtOiBLdGRHcmlkTGF5b3V0SXRlbSA9IHtcclxuICAgICAgICAuLi5kcmFnZ2luZ0VsZW1QcmV2SXRlbSxcclxuICAgICAgICB3OiBzY3JlZW5YUG9zVG9HcmlkVmFsdWUod2lkdGgsIGNvbmZpZy5jb2xzLCBncmlkRWxlbUNsaWVudFJlY3Qud2lkdGgpLFxyXG4gICAgICAgIGg6IHNjcmVlbllQb3NUb0dyaWRWYWx1ZShoZWlnaHQsIGNvbmZpZy5yb3dIZWlnaHQsIGdyaWRFbGVtQ2xpZW50UmVjdC5oZWlnaHQpXHJcbiAgICB9O1xyXG5cclxuICAgIGxheW91dEl0ZW0udyA9IGxpbWl0TnVtYmVyV2l0aGluUmFuZ2UobGF5b3V0SXRlbS53LCBncmlkSXRlbS5taW5XID8/IGxheW91dEl0ZW0ubWluVywgZ3JpZEl0ZW0ubWF4VyA/PyBsYXlvdXRJdGVtLm1heFcpO1xyXG4gICAgbGF5b3V0SXRlbS5oID0gbGltaXROdW1iZXJXaXRoaW5SYW5nZShsYXlvdXRJdGVtLmgsIGdyaWRJdGVtLm1pbkggPz8gbGF5b3V0SXRlbS5taW5ILCBncmlkSXRlbS5tYXhIID8/IGxheW91dEl0ZW0ubWF4SCk7XHJcblxyXG4gICAgaWYgKGxheW91dEl0ZW0ueCArIGxheW91dEl0ZW0udyA+IGNvbmZpZy5jb2xzKSB7XHJcbiAgICAgICAgbGF5b3V0SXRlbS53ID0gTWF0aC5tYXgoMSwgY29uZmlnLmNvbHMgLSBsYXlvdXRJdGVtLngpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcucHJldmVudENvbGxpc2lvbikge1xyXG4gICAgICAgIGNvbnN0IG1heFcgPSBsYXlvdXRJdGVtLnc7XHJcbiAgICAgICAgY29uc3QgbWF4SCA9IGxheW91dEl0ZW0uaDtcclxuXHJcbiAgICAgICAgbGV0IGNvbGxpZGluZyA9IGhhc0NvbGxpc2lvbihjb25maWcubGF5b3V0LCBsYXlvdXRJdGVtKTtcclxuICAgICAgICBsZXQgc2hydW5rRGltZW5zaW9uOiAndycgfCAnaCcgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChjb2xsaWRpbmcpIHtcclxuICAgICAgICAgICAgc2hydW5rRGltZW5zaW9uID0gZ2V0RGltZW5zaW9uVG9TaHJpbmsobGF5b3V0SXRlbSwgc2hydW5rRGltZW5zaW9uKTtcclxuICAgICAgICAgICAgbGF5b3V0SXRlbVtzaHJ1bmtEaW1lbnNpb25dLS07XHJcbiAgICAgICAgICAgIGNvbGxpZGluZyA9IGhhc0NvbGxpc2lvbihjb25maWcubGF5b3V0LCBsYXlvdXRJdGVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaHJ1bmtEaW1lbnNpb24gPT09ICd3Jykge1xyXG4gICAgICAgICAgICBsYXlvdXRJdGVtLmggPSBtYXhIO1xyXG5cclxuICAgICAgICAgICAgY29sbGlkaW5nID0gaGFzQ29sbGlzaW9uKGNvbmZpZy5sYXlvdXQsIGxheW91dEl0ZW0pO1xyXG4gICAgICAgICAgICB3aGlsZSAoY29sbGlkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRJdGVtLmgtLTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGluZyA9IGhhc0NvbGxpc2lvbihjb25maWcubGF5b3V0LCBsYXlvdXRJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hydW5rRGltZW5zaW9uID09PSAnaCcpIHtcclxuICAgICAgICAgICAgbGF5b3V0SXRlbS53ID0gbWF4VztcclxuXHJcbiAgICAgICAgICAgIGNvbGxpZGluZyA9IGhhc0NvbGxpc2lvbihjb25maWcubGF5b3V0LCBsYXlvdXRJdGVtKTtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbGxpZGluZykge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0SXRlbS53LS07XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRpbmcgPSBoYXNDb2xsaXNpb24oY29uZmlnLmxheW91dCwgbGF5b3V0SXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5ld0xheW91dEl0ZW1zOiBMYXlvdXRJdGVtW10gPSBjb25maWcubGF5b3V0Lm1hcCgoaXRlbSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmlkID09PSBncmlkSXRlbUlkID8gbGF5b3V0SXRlbSA6IGl0ZW07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxheW91dDogY29tcGFjdChuZXdMYXlvdXRJdGVtcywgY29tcGFjdGlvblR5cGUsIGNvbmZpZy5jb2xzKSxcclxuICAgICAgICBkcmFnZ2VkSXRlbVBvczoge1xyXG4gICAgICAgICAgICB0b3A6IGRyYWdFbGVtQ2xpZW50UmVjdC50b3AgLSBncmlkRWxlbUNsaWVudFJlY3QudG9wLFxyXG4gICAgICAgICAgICBsZWZ0OiBkcmFnRWxlbUNsaWVudFJlY3QubGVmdCAtIGdyaWRFbGVtQ2xpZW50UmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc0NvbGxpc2lvbihsYXlvdXQ6IExheW91dCwgbGF5b3V0SXRlbTogTGF5b3V0SXRlbSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuICEhZ2V0Rmlyc3RDb2xsaXNpb24obGF5b3V0LCBsYXlvdXRJdGVtKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGltZW5zaW9uVG9TaHJpbmsobGF5b3V0SXRlbSwgbGFzdFNocnVuayk6ICd3JyB8ICdoJyB7XHJcbiAgICBpZiAobGF5b3V0SXRlbS5oIDw9IDEpIHtcclxuICAgICAgICByZXR1cm4gJ3cnO1xyXG4gICAgfVxyXG4gICAgaWYgKGxheW91dEl0ZW0udyA8PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuICdoJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGFzdFNocnVuayA9PT0gJ3cnID8gJ2gnIDogJ3cnO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gdGhlIGN1cnJlbnQgbnVtYmVyIGFuZCBtaW4vbWF4IHZhbHVlcywgcmV0dXJucyB0aGUgbnVtYmVyIHdpdGhpbiB0aGUgcmFuZ2VcclxuICogQHBhcmFtIG51bWJlciBjYW4gYmUgYW55IG51bWVyaWMgdmFsdWVcclxuICogQHBhcmFtIG1pbiBtaW5pbXVtIHZhbHVlIG9mIHJhbmdlXHJcbiAqIEBwYXJhbSBtYXggbWF4aW11bSB2YWx1ZSBvZiByYW5nZVxyXG4gKi9cclxuZnVuY3Rpb24gbGltaXROdW1iZXJXaXRoaW5SYW5nZShudW06IG51bWJlciwgbWluOiBudW1iZXIgPSAxLCBtYXg6IG51bWJlciA9IEluZmluaXR5KSB7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4gPCAxID8gMSA6IG1pbiksIG1heCk7XHJcbn1cclxuIl19