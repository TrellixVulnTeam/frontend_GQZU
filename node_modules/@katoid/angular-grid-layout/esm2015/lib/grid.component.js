import { ChangeDetectionStrategy, Component, ContentChildren, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { coerceNumberProperty } from './coercion/number-property';
import { KtdGridItemComponent } from './grid-item/grid-item.component';
import { combineLatest, merge, NEVER, Observable, of } from 'rxjs';
import { exhaustMap, map, startWith, switchMap, takeUntil } from 'rxjs/operators';
import { ktdGridItemDragging, ktdGridItemResizing } from './utils/grid.utils';
import { compact } from './utils/react-grid-layout.utils';
import { GRID_ITEM_GET_RENDER_DATA_TOKEN } from './grid.definitions';
import { ktdMouseOrTouchEnd, ktdPointerClientX, ktdPointerClientY } from './utils/pointer.utils';
import { getMutableClientRect } from './utils/client-rect';
import { ktdGetScrollTotalRelativeDifference$, ktdScrollIfNearElementClientRect$ } from './utils/scroll';
import { coerceBooleanProperty } from './coercion/boolean-property';
import * as i0 from "@angular/core";
import * as i1 from "./grid.service";
function getDragResizeEventData(gridItem, layout) {
    return {
        layout,
        layoutItem: layout.find((item) => item.id === gridItem.id),
        gridItemRef: gridItem
    };
}
function layoutToRenderItems(config, width, height) {
    const { cols, rowHeight, layout } = config;
    const renderItems = {};
    for (const item of layout) {
        renderItems[item.id] = {
            id: item.id,
            top: item.y === 0 ? 0 : item.y * rowHeight,
            left: item.x * (width / cols),
            width: item.w * (width / cols),
            height: item.h * rowHeight
        };
    }
    return renderItems;
}
function getGridHeight(layout, rowHeight) {
    return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);
}
// tslint:disable-next-line
export function parseRenderItemToPixels(renderItem) {
    return {
        id: renderItem.id,
        top: `${renderItem.top}px`,
        left: `${renderItem.left}px`,
        width: `${renderItem.width}px`,
        height: `${renderItem.height}px`
    };
}
// tslint:disable-next-line:ktd-prefix-code
export function __gridItemGetRenderDataFactoryFunc(gridCmp) {
    // tslint:disable-next-line:only-arrow-functions
    return function (id) {
        return parseRenderItemToPixels(gridCmp.getItemRenderData(id));
    };
}
export function ktdGridItemGetRenderDataFactoryFunc(gridCmp) {
    // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613
    const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);
    return resultFunc;
}
export class KtdGridComponent {
    constructor(gridService, elementRef, renderer, ngZone) {
        this.gridService = gridService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /** Emits when layout change */
        this.layoutUpdated = new EventEmitter();
        /** Emits when drag starts */
        this.dragStarted = new EventEmitter();
        /** Emits when resize starts */
        this.resizeStarted = new EventEmitter();
        /** Emits when drag ends */
        this.dragEnded = new EventEmitter();
        /** Emits when resize ends */
        this.resizeEnded = new EventEmitter();
        /**
         * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.
         * If no data provided or null autoscroll is not performed.
         */
        this.scrollableParent = null;
        this._compactOnPropsChange = true;
        this._preventCollision = false;
        this._scrollSpeed = 2;
        this._compactType = 'vertical';
        this._rowHeight = 100;
        this._cols = 6;
    }
    /** Whether or not to update the internal layout when some dependent property change. */
    get compactOnPropsChange() { return this._compactOnPropsChange; }
    set compactOnPropsChange(value) {
        this._compactOnPropsChange = coerceBooleanProperty(value);
    }
    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */
    get preventCollision() { return this._preventCollision; }
    set preventCollision(value) {
        this._preventCollision = coerceBooleanProperty(value);
    }
    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */
    get scrollSpeed() { return this._scrollSpeed; }
    set scrollSpeed(value) {
        this._scrollSpeed = coerceNumberProperty(value, 2);
    }
    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */
    get compactType() {
        return this._compactType;
    }
    set compactType(val) {
        this._compactType = val;
    }
    /** Row height in css pixels */
    get rowHeight() { return this._rowHeight; }
    set rowHeight(val) {
        this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));
    }
    /** Number of columns  */
    get cols() { return this._cols; }
    set cols(val) {
        this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));
    }
    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */
    get layout() { return this._layout; }
    set layout(layout) {
        /**
         * Enhancement:
         * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.
         *
         * Why:
         * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and
         * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when
         * it is re-binded on the input.
         */
        this._layout = layout;
    }
    get config() {
        return {
            cols: this.cols,
            rowHeight: this.rowHeight,
            layout: this.layout,
            preventCollision: this.preventCollision,
        };
    }
    ngOnChanges(changes) {
        let needsCompactLayout = false;
        let needsRecalculateRenderData = false;
        // TODO: Does fist change need to be compacted by default?
        // Compact layout whenever some dependent prop changes.
        if (changes.compactType || changes.cols || changes.layout) {
            needsCompactLayout = true;
        }
        // Check if wee need to recalculate rendering data.
        if (needsCompactLayout || changes.rowHeight) {
            needsRecalculateRenderData = true;
        }
        // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)
        // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component
        // and the ones that uses it.
        if (needsCompactLayout && this.compactOnPropsChange) {
            this.compactLayout();
        }
        if (needsRecalculateRenderData) {
            this.calculateRenderData();
        }
    }
    ngAfterContentInit() {
        this.initSubscriptions();
    }
    ngAfterContentChecked() {
        this.render();
    }
    resize() {
        this.calculateRenderData();
        this.render();
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    compactLayout() {
        this.layout = compact(this.layout, this.compactType, this.cols);
    }
    getItemsRenderData() {
        return Object.assign({}, this._gridItemsRenderData);
    }
    getItemRenderData(itemId) {
        return this._gridItemsRenderData[itemId];
    }
    calculateRenderData() {
        const clientRect = this.elementRef.nativeElement.getBoundingClientRect();
        this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);
        this._height = getGridHeight(this.layout, this.rowHeight);
    }
    render() {
        this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);
        this.updateGridItemsStyles();
    }
    updateGridItemsStyles() {
        this._gridItems.forEach(item => {
            const gridItemRenderData = this._gridItemsRenderData[item.id];
            if (gridItemRenderData == null) {
                console.error(`Couldn\'t find the specified grid item for the id: ${item.id}`);
            }
            else {
                item.setStyles(parseRenderItemToPixels(gridItemRenderData));
            }
        });
    }
    initSubscriptions() {
        this.subscriptions = [
            this._gridItems.changes.pipe(startWith(this._gridItems), switchMap((gridItems) => {
                return merge(...gridItems.map((gridItem) => gridItem.dragStart$.pipe(map((event) => ({ event, gridItem, type: 'drag' })))), ...gridItems.map((gridItem) => gridItem.resizeStart$.pipe(map((event) => ({ event, gridItem, type: 'resize' }))))).pipe(exhaustMap(({ event, gridItem, type }) => {
                    // Emit drag or resize start events. Ensure that is start event is inside the zone.
                    this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout)));
                    // Get the correct newStateFunc depending on if we are dragging or resizing
                    const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing;
                    // Perform drag sequence
                    return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) => calcNewStateFunc(gridItem, config, compactionType, draggingData)).pipe(map((layout) => ({ layout, gridItem, type })));
                }));
            })).subscribe(({ layout, gridItem, type }) => {
                this.layout = layout;
                // Calculate new rendering data given the new layout.
                this.calculateRenderData();
                // Emit drag or resize end events.
                (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout));
                // Notify that the layout has been updated.
                this.layoutUpdated.emit(layout);
            })
        ];
    }
    /**
     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding
     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.
     * @param gridItem that is been dragged
     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag
     * @param calcNewStateFunc function that return the new layout state and the drag element position
     */
    performDragSequence$(gridItem, pointerDownEvent, calcNewStateFunc) {
        return new Observable((observer) => {
            // Retrieve grid (parent) and gridItem (draggedElem) client rects.
            const gridElemClientRect = getMutableClientRect(this.elementRef.nativeElement);
            const dragElemClientRect = getMutableClientRect(gridItem.elementRef.nativeElement);
            const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;
            this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');
            this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');
            // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends
            const placeholderElement = this.renderer.createElement('div');
            placeholderElement.style.width = `${dragElemClientRect.width}px`;
            placeholderElement.style.height = `${dragElemClientRect.height}px`;
            placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;
            this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');
            this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);
            let newLayout;
            // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.
            //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.
            //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.
            const scrollSubscription = this.ngZone.runOutsideAngular(() => (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(map((event) => ({
                pointerX: ktdPointerClientX(event),
                pointerY: ktdPointerClientY(event)
            })), ktdScrollIfNearElementClientRect$(scrollableParent, { scrollStep: this.scrollSpeed }))).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe());
            /**
             * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission
             */
            const subscription = this.ngZone.runOutsideAngular(() => merge(combineLatest([
                this.gridService.mouseOrTouchMove$(document),
                ...(!scrollableParent ? [of({ top: 0, left: 0 })] : [
                    ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(startWith({ top: 0, left: 0 }) // Force first emission to allow CombineLatest to emit even no scroll event has occurred
                    )
                ])
            ])).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe(([pointerDragEvent, scrollDifference]) => {
                pointerDragEvent.preventDefault();
                /**
                 * Set the new layout to be the layout in which the calcNewStateFunc would be executed.
                 * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,
                 * some utilities from 'react-grid-layout' would not work as expected.
                 */
                const currentLayout = newLayout || this.layout;
                const { layout, draggedItemPos } = calcNewStateFunc(gridItem, {
                    layout: currentLayout,
                    rowHeight: this.rowHeight,
                    cols: this.cols,
                    preventCollision: this.preventCollision
                }, this.compactType, {
                    pointerDownEvent,
                    pointerDragEvent,
                    gridElemClientRect,
                    dragElemClientRect,
                    scrollDifference
                });
                newLayout = layout;
                this._height = getGridHeight(newLayout, this.rowHeight);
                this._gridItemsRenderData = layoutToRenderItems({
                    cols: this.cols,
                    rowHeight: this.rowHeight,
                    layout: newLayout,
                    preventCollision: this.preventCollision,
                }, gridElemClientRect.width, gridElemClientRect.height);
                const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]);
                // Put the real final position to the placeholder element
                placeholderElement.style.width = placeholderStyles.width;
                placeholderElement.style.height = placeholderStyles.height;
                placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`;
                // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)
                this._gridItemsRenderData[gridItem.id] = Object.assign(Object.assign({}, draggedItemPos), { id: this._gridItemsRenderData[gridItem.id].id });
                this.render();
            }, (error) => observer.error(error), () => {
                this.ngZone.run(() => {
                    // Remove drag classes
                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');
                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');
                    // Remove placeholder element from the dom
                    // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.
                    // It should work since AFAIK this action should not be done in a CD cycle.
                    this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);
                    if (newLayout) {
                        // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.
                        // Prune react-grid-layout compact extra properties.
                        observer.next(newLayout.map(item => ({
                            id: item.id,
                            x: item.x,
                            y: item.y,
                            w: item.w,
                            h: item.h,
                            minW: item.minW,
                            minH: item.minH,
                            maxW: item.maxW,
                            maxH: item.maxH,
                        })));
                    }
                    else {
                        // TODO: Need we really to emit if there is no layout change but drag started and ended?
                        observer.next(this.layout);
                    }
                    observer.complete();
                });
            }));
            return () => {
                scrollSubscription.unsubscribe();
                subscription.unsubscribe();
            };
        });
    }
}
KtdGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: KtdGridComponent, deps: [{ token: i1.KtdGridService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
KtdGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: KtdGridComponent, selector: "ktd-grid", inputs: { scrollableParent: "scrollableParent", compactOnPropsChange: "compactOnPropsChange", preventCollision: "preventCollision", scrollSpeed: "scrollSpeed", compactType: "compactType", rowHeight: "rowHeight", cols: "cols", layout: "layout" }, outputs: { layoutUpdated: "layoutUpdated", dragStarted: "dragStarted", resizeStarted: "resizeStarted", dragEnded: "dragEnded", resizeEnded: "resizeEnded" }, providers: [
        {
            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,
            useFactory: ktdGridItemGetRenderDataFactoryFunc,
            deps: [KtdGridComponent]
        }
    ], queries: [{ propertyName: "_gridItems", predicate: KtdGridItemComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: "<ng-content></ng-content>\r\n", styles: ["ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;background-color:#8b0000;opacity:.6;z-index:0;transition-property:transform;transition:all .15s ease}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: KtdGridComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ktd-grid',
                    templateUrl: './grid.component.html',
                    styleUrls: ['./grid.component.scss'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,
                            useFactory: ktdGridItemGetRenderDataFactoryFunc,
                            deps: [KtdGridComponent]
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i1.KtdGridService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { _gridItems: [{
                type: ContentChildren,
                args: [KtdGridItemComponent, { descendants: true }]
            }], layoutUpdated: [{
                type: Output
            }], dragStarted: [{
                type: Output
            }], resizeStarted: [{
                type: Output
            }], dragEnded: [{
                type: Output
            }], resizeEnded: [{
                type: Output
            }], scrollableParent: [{
                type: Input
            }], compactOnPropsChange: [{
                type: Input
            }], preventCollision: [{
                type: Input
            }], scrollSpeed: [{
                type: Input
            }], compactType: [{
                type: Input
            }], rowHeight: [{
                type: Input
            }], cols: [{
                type: Input
            }], layout: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWdyaWQtbGF5b3V0L3NyYy9saWIvZ3JpZC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWdyaWQtbGF5b3V0L3NyYy9saWIvZ3JpZC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ29DLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQWMsWUFBWSxFQUFFLEtBQUssRUFDaEgsTUFBTSxFQUF1QyxpQkFBaUIsRUFDNUUsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLG9CQUFvQixFQUFlLE1BQU0sNEJBQTRCLENBQUM7QUFDL0UsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDdkUsT0FBTyxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBWSxFQUFFLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQzNGLE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDOUUsT0FBTyxFQUFFLE9BQU8sRUFBZSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3ZFLE9BQU8sRUFDSCwrQkFBK0IsRUFFbEMsTUFBTSxvQkFBb0IsQ0FBQztBQUM1QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsaUJBQWlCLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUdqRyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsb0NBQW9DLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSxn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TTtzQkFEVCxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICAgIEFmdGVyQ29udGVudENoZWNrZWQsIEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgTmdab25lLCBPbkNoYW5nZXMsXHJcbiAgICBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0LCBSZW5kZXJlcjIsIFNpbXBsZUNoYW5nZXMsIFZpZXdFbmNhcHN1bGF0aW9uXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGNvZXJjZU51bWJlclByb3BlcnR5LCBOdW1iZXJJbnB1dCB9IGZyb20gJy4vY29lcmNpb24vbnVtYmVyLXByb3BlcnR5JztcclxuaW1wb3J0IHsgS3RkR3JpZEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2dyaWQtaXRlbS9ncmlkLWl0ZW0uY29tcG9uZW50JztcclxuaW1wb3J0IHsgY29tYmluZUxhdGVzdCwgbWVyZ2UsIE5FVkVSLCBPYnNlcnZhYmxlLCBPYnNlcnZlciwgb2YsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBleGhhdXN0TWFwLCBtYXAsIHN0YXJ0V2l0aCwgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IGt0ZEdyaWRJdGVtRHJhZ2dpbmcsIGt0ZEdyaWRJdGVtUmVzaXppbmcgfSBmcm9tICcuL3V0aWxzL2dyaWQudXRpbHMnO1xyXG5pbXBvcnQgeyBjb21wYWN0LCBDb21wYWN0VHlwZSB9IGZyb20gJy4vdXRpbHMvcmVhY3QtZ3JpZC1sYXlvdXQudXRpbHMnO1xyXG5pbXBvcnQge1xyXG4gICAgR1JJRF9JVEVNX0dFVF9SRU5ERVJfREFUQV9UT0tFTiwgS3RkRHJhZ2dpbmdEYXRhLCBLdGRHcmlkQ2ZnLCBLdGRHcmlkQ29tcGFjdFR5cGUsIEt0ZEdyaWRJdGVtUmVjdCwgS3RkR3JpZEl0ZW1SZW5kZXJEYXRhLCBLdGRHcmlkTGF5b3V0LFxyXG4gICAgS3RkR3JpZExheW91dEl0ZW1cclxufSBmcm9tICcuL2dyaWQuZGVmaW5pdGlvbnMnO1xyXG5pbXBvcnQgeyBrdGRNb3VzZU9yVG91Y2hFbmQsIGt0ZFBvaW50ZXJDbGllbnRYLCBrdGRQb2ludGVyQ2xpZW50WSB9IGZyb20gJy4vdXRpbHMvcG9pbnRlci51dGlscyc7XHJcbmltcG9ydCB7IEt0ZERpY3Rpb25hcnkgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IEt0ZEdyaWRTZXJ2aWNlIH0gZnJvbSAnLi9ncmlkLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBnZXRNdXRhYmxlQ2xpZW50UmVjdCB9IGZyb20gJy4vdXRpbHMvY2xpZW50LXJlY3QnO1xyXG5pbXBvcnQgeyBrdGRHZXRTY3JvbGxUb3RhbFJlbGF0aXZlRGlmZmVyZW5jZSQsIGt0ZFNjcm9sbElmTmVhckVsZW1lbnRDbGllbnRSZWN0JCB9IGZyb20gJy4vdXRpbHMvc2Nyb2xsJztcclxuaW1wb3J0IHsgQm9vbGVhbklucHV0LCBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICcuL2NvZXJjaW9uL2Jvb2xlYW4tcHJvcGVydHknO1xyXG5cclxuaW50ZXJmYWNlIEt0ZERyYWdSZXNpemVFdmVudCB7XHJcbiAgICBsYXlvdXQ6IEt0ZEdyaWRMYXlvdXQ7XHJcbiAgICBsYXlvdXRJdGVtOiBLdGRHcmlkTGF5b3V0SXRlbTtcclxuICAgIGdyaWRJdGVtUmVmOiBLdGRHcmlkSXRlbUNvbXBvbmVudDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgS3RkRHJhZ1N0YXJ0ID0gS3RkRHJhZ1Jlc2l6ZUV2ZW50O1xyXG5leHBvcnQgdHlwZSBLdGRSZXNpemVTdGFydCA9IEt0ZERyYWdSZXNpemVFdmVudDtcclxuZXhwb3J0IHR5cGUgS3RkRHJhZ0VuZCA9IEt0ZERyYWdSZXNpemVFdmVudDtcclxuZXhwb3J0IHR5cGUgS3RkUmVzaXplRW5kID0gS3RkRHJhZ1Jlc2l6ZUV2ZW50O1xyXG5cclxuZnVuY3Rpb24gZ2V0RHJhZ1Jlc2l6ZUV2ZW50RGF0YShncmlkSXRlbTogS3RkR3JpZEl0ZW1Db21wb25lbnQsIGxheW91dDogS3RkR3JpZExheW91dCk6IEt0ZERyYWdSZXNpemVFdmVudCB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxheW91dCxcclxuICAgICAgICBsYXlvdXRJdGVtOiBsYXlvdXQuZmluZCgoaXRlbSkgPT4gaXRlbS5pZCA9PT0gZ3JpZEl0ZW0uaWQpISxcclxuICAgICAgICBncmlkSXRlbVJlZjogZ3JpZEl0ZW1cclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBsYXlvdXRUb1JlbmRlckl0ZW1zKGNvbmZpZzogS3RkR3JpZENmZywgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBLdGREaWN0aW9uYXJ5PEt0ZEdyaWRJdGVtUmVuZGVyRGF0YTxudW1iZXI+PiB7XHJcbiAgICBjb25zdCB7Y29scywgcm93SGVpZ2h0LCBsYXlvdXR9ID0gY29uZmlnO1xyXG5cclxuICAgIGNvbnN0IHJlbmRlckl0ZW1zOiBLdGREaWN0aW9uYXJ5PEt0ZEdyaWRJdGVtUmVuZGVyRGF0YTxudW1iZXI+PiA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGxheW91dCkge1xyXG4gICAgICAgIHJlbmRlckl0ZW1zW2l0ZW0uaWRdID0ge1xyXG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcclxuICAgICAgICAgICAgdG9wOiBpdGVtLnkgPT09IDAgPyAwIDogaXRlbS55ICogcm93SGVpZ2h0LFxyXG4gICAgICAgICAgICBsZWZ0OiBpdGVtLnggKiAod2lkdGggLyBjb2xzKSxcclxuICAgICAgICAgICAgd2lkdGg6IGl0ZW0udyAqICh3aWR0aCAvIGNvbHMpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGl0ZW0uaCAqIHJvd0hlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVuZGVySXRlbXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEdyaWRIZWlnaHQobGF5b3V0OiBLdGRHcmlkTGF5b3V0LCByb3dIZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gbGF5b3V0LnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgKGN1ci55ICsgY3VyLmgpICogcm93SGVpZ2h0KSwgMCk7XHJcbn1cclxuXHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZW5kZXJJdGVtVG9QaXhlbHMocmVuZGVySXRlbTogS3RkR3JpZEl0ZW1SZW5kZXJEYXRhPG51bWJlcj4pOiBLdGRHcmlkSXRlbVJlbmRlckRhdGE8c3RyaW5nPiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiByZW5kZXJJdGVtLmlkLFxyXG4gICAgICAgIHRvcDogYCR7cmVuZGVySXRlbS50b3B9cHhgLFxyXG4gICAgICAgIGxlZnQ6IGAke3JlbmRlckl0ZW0ubGVmdH1weGAsXHJcbiAgICAgICAgd2lkdGg6IGAke3JlbmRlckl0ZW0ud2lkdGh9cHhgLFxyXG4gICAgICAgIGhlaWdodDogYCR7cmVuZGVySXRlbS5oZWlnaHR9cHhgXHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6a3RkLXByZWZpeC1jb2RlXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dyaWRJdGVtR2V0UmVuZGVyRGF0YUZhY3RvcnlGdW5jKGdyaWRDbXA6IEt0ZEdyaWRDb21wb25lbnQpIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpvbmx5LWFycm93LWZ1bmN0aW9uc1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGlkOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VSZW5kZXJJdGVtVG9QaXhlbHMoZ3JpZENtcC5nZXRJdGVtUmVuZGVyRGF0YShpZCkpO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGt0ZEdyaWRJdGVtR2V0UmVuZGVyRGF0YUZhY3RvcnlGdW5jKGdyaWRDbXA6IEt0ZEdyaWRDb21wb25lbnQpIHtcclxuICAgIC8vIFdvcmthcm91bmQgZXhwbGFpbmVkOiBodHRwczovL2dpdGh1Yi5jb20vbmctcGFja2Fnci9uZy1wYWNrYWdyL2lzc3Vlcy82OTYjaXNzdWVjb21tZW50LTM4NzExNDYxM1xyXG4gICAgY29uc3QgcmVzdWx0RnVuYyA9IF9fZ3JpZEl0ZW1HZXRSZW5kZXJEYXRhRmFjdG9yeUZ1bmMoZ3JpZENtcCk7XHJcbiAgICByZXR1cm4gcmVzdWx0RnVuYztcclxufVxyXG5cclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdrdGQtZ3JpZCcsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vZ3JpZC5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnLi9ncmlkLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb3ZpZGU6IEdSSURfSVRFTV9HRVRfUkVOREVSX0RBVEFfVE9LRU4sXHJcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGt0ZEdyaWRJdGVtR2V0UmVuZGVyRGF0YUZhY3RvcnlGdW5jLFxyXG4gICAgICAgICAgICBkZXBzOiBbS3RkR3JpZENvbXBvbmVudF1cclxuICAgICAgICB9XHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBLdGRHcmlkQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0LCBBZnRlckNvbnRlbnRDaGVja2VkLCBPbkRlc3Ryb3kge1xyXG4gICAgLyoqIFF1ZXJ5IGxpc3Qgb2YgZ3JpZCBpdGVtcyB0aGF0IGFyZSBiZWluZyByZW5kZXJlZC4gKi9cclxuICAgIEBDb250ZW50Q2hpbGRyZW4oS3RkR3JpZEl0ZW1Db21wb25lbnQsIHtkZXNjZW5kYW50czogdHJ1ZX0pIF9ncmlkSXRlbXM6IFF1ZXJ5TGlzdDxLdGRHcmlkSXRlbUNvbXBvbmVudD47XHJcblxyXG4gICAgLyoqIEVtaXRzIHdoZW4gbGF5b3V0IGNoYW5nZSAqL1xyXG4gICAgQE91dHB1dCgpIGxheW91dFVwZGF0ZWQ6IEV2ZW50RW1pdHRlcjxLdGRHcmlkTGF5b3V0PiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkR3JpZExheW91dD4oKTtcclxuXHJcbiAgICAvKiogRW1pdHMgd2hlbiBkcmFnIHN0YXJ0cyAqL1xyXG4gICAgQE91dHB1dCgpIGRyYWdTdGFydGVkOiBFdmVudEVtaXR0ZXI8S3RkRHJhZ1N0YXJ0PiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkRHJhZ1N0YXJ0PigpO1xyXG5cclxuICAgIC8qKiBFbWl0cyB3aGVuIHJlc2l6ZSBzdGFydHMgKi9cclxuICAgIEBPdXRwdXQoKSByZXNpemVTdGFydGVkOiBFdmVudEVtaXR0ZXI8S3RkUmVzaXplU3RhcnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxLdGRSZXNpemVTdGFydD4oKTtcclxuXHJcbiAgICAvKiogRW1pdHMgd2hlbiBkcmFnIGVuZHMgKi9cclxuICAgIEBPdXRwdXQoKSBkcmFnRW5kZWQ6IEV2ZW50RW1pdHRlcjxLdGREcmFnRW5kPiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkRHJhZ0VuZD4oKTtcclxuXHJcbiAgICAvKiogRW1pdHMgd2hlbiByZXNpemUgZW5kcyAqL1xyXG4gICAgQE91dHB1dCgpIHJlc2l6ZUVuZGVkOiBFdmVudEVtaXR0ZXI8S3RkUmVzaXplRW5kPiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkUmVzaXplRW5kPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyZW50IGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgc2Nyb2xsLiBJZiBhbiBzdHJpbmcgaXMgcHJvdmlkZWQgaXQgd291bGQgc2VhcmNoIHRoYXQgZWxlbWVudCBieSBpZCBvbiB0aGUgZG9tLlxyXG4gICAgICogSWYgbm8gZGF0YSBwcm92aWRlZCBvciBudWxsIGF1dG9zY3JvbGwgaXMgbm90IHBlcmZvcm1lZC5cclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgc2Nyb2xsYWJsZVBhcmVudDogSFRNTEVsZW1lbnQgfCBEb2N1bWVudCB8IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0byB1cGRhdGUgdGhlIGludGVybmFsIGxheW91dCB3aGVuIHNvbWUgZGVwZW5kZW50IHByb3BlcnR5IGNoYW5nZS4gKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgY29tcGFjdE9uUHJvcHNDaGFuZ2UoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9jb21wYWN0T25Qcm9wc0NoYW5nZTsgfVxyXG5cclxuICAgIHNldCBjb21wYWN0T25Qcm9wc0NoYW5nZSh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX2NvbXBhY3RPblByb3BzQ2hhbmdlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jb21wYWN0T25Qcm9wc0NoYW5nZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgLyoqIElmIHRydWUsIGdyaWQgaXRlbXMgd29uJ3QgY2hhbmdlIHBvc2l0aW9uIHdoZW4gYmVpbmcgZHJhZ2dlZCBvdmVyLiBIYW5keSB3aGVuIHVzaW5nIG5vIGNvbXBhY3Rpb24gKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgcHJldmVudENvbGxpc2lvbigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3ByZXZlbnRDb2xsaXNpb247IH1cclxuXHJcbiAgICBzZXQgcHJldmVudENvbGxpc2lvbih2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX3ByZXZlbnRDb2xsaXNpb24gPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3ByZXZlbnRDb2xsaXNpb246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKiogTnVtYmVyIG9mIENTUyBwaXhlbHMgdGhhdCB3b3VsZCBiZSBzY3JvbGxlZCBvbiBlYWNoICd0aWNrJyB3aGVuIGF1dG8gc2Nyb2xsIGlzIHBlcmZvcm1lZC4gKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgc2Nyb2xsU3BlZWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3Njcm9sbFNwZWVkOyB9XHJcblxyXG4gICAgc2V0IHNjcm9sbFNwZWVkKHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9zY3JvbGxTcGVlZCA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlLCAyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9zY3JvbGxTcGVlZDogbnVtYmVyID0gMjtcclxuXHJcbiAgICAvKiogVHlwZSBvZiBjb21wYWN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBsYXlvdXQgKHZlcnRpY2FsLCBob3Jpem9udGFsIG9yIGZyZWUpLiBEZWZhdWx0cyB0byAndmVydGljYWwnICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGNvbXBhY3RUeXBlKCk6IEt0ZEdyaWRDb21wYWN0VHlwZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBhY3RUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBjb21wYWN0VHlwZSh2YWw6IEt0ZEdyaWRDb21wYWN0VHlwZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbXBhY3RUeXBlID0gdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NvbXBhY3RUeXBlOiBLdGRHcmlkQ29tcGFjdFR5cGUgPSAndmVydGljYWwnO1xyXG5cclxuICAgIC8qKiBSb3cgaGVpZ2h0IGluIGNzcyBwaXhlbHMgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgcm93SGVpZ2h0KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9yb3dIZWlnaHQ7IH1cclxuXHJcbiAgICBzZXQgcm93SGVpZ2h0KHZhbDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fcm93SGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWwpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfcm93SGVpZ2h0OiBudW1iZXIgPSAxMDA7XHJcblxyXG4gICAgLyoqIE51bWJlciBvZiBjb2x1bW5zICAqL1xyXG4gICAgQElucHV0KClcclxuICAgIGdldCBjb2xzKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9jb2xzOyB9XHJcblxyXG4gICAgc2V0IGNvbHModmFsOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9jb2xzID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWwpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY29sczogbnVtYmVyID0gNjtcclxuXHJcbiAgICAvKiogTGF5b3V0IG9mIHRoZSBncmlkLiBBcnJheSBvZiBhbGwgdGhlIGdyaWQgaXRlbXMgd2l0aCBpdHMgJ2lkJyBhbmQgcG9zaXRpb24gb24gdGhlIGdyaWQuICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGxheW91dCgpOiBLdGRHcmlkTGF5b3V0IHsgcmV0dXJuIHRoaXMuX2xheW91dDsgfVxyXG5cclxuICAgIHNldCBsYXlvdXQobGF5b3V0OiBLdGRHcmlkTGF5b3V0KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5oYW5jZW1lbnQ6XHJcbiAgICAgICAgICogT25seSBzZXQgbGF5b3V0IGlmIGl0J3MgcmVmZXJlbmNlIGhhcyBjaGFuZ2VkIGFuZCB1c2UgYSBib29sZWFuIHRvIHRyYWNrIHdoZW5ldmVyIHJlY2FsY3VsYXRlIHRoZSBsYXlvdXQgb24gbmdPbkNoYW5nZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaHk6XHJcbiAgICAgICAgICogVGhlIG5vcm1hbCB1c2Ugb2YgdGhpcyBsaWIgaXMgaGF2aW5nIHRoZSB2YXJpYWJsZSBsYXlvdXQgaW4gdGhlIG91dGVyIGNvbXBvbmVudCBvciBpbiBhIHN0b3JlLCBhc3NpZ25pbmcgaXQgd2hlbmV2ZXIgaXQgY2hhbmdlcyBhbmRcclxuICAgICAgICAgKiBiaW5kZWQgaW4gdGhlIGNvbXBvbmVudCB3aXRoIGl0J3MgaW5wdXQgW2xheW91dF0uIEluIHRoaXMgc2NlbmFyaW8sIHdlIHdvdWxkIGFsd2F5cyBjYWxjdWxhdGUgb25lIHVubmVjZXNzYXJ5IGNoYW5nZSBvbiB0aGUgbGF5b3V0IHdoZW5cclxuICAgICAgICAgKiBpdCBpcyByZS1iaW5kZWQgb24gdGhlIGlucHV0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9sYXlvdXQ6IEt0ZEdyaWRMYXlvdXQ7XHJcblxyXG4gICAgZ2V0IGNvbmZpZygpOiBLdGRHcmlkQ2ZnIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2xzOiB0aGlzLmNvbHMsXHJcbiAgICAgICAgICAgIHJvd0hlaWdodDogdGhpcy5yb3dIZWlnaHQsXHJcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5sYXlvdXQsXHJcbiAgICAgICAgICAgIHByZXZlbnRDb2xsaXNpb246IHRoaXMucHJldmVudENvbGxpc2lvbixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUb3RhbCBoZWlnaHQgb2YgdGhlIGdyaWQgKi9cclxuICAgIHByaXZhdGUgX2hlaWdodDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfZ3JpZEl0ZW1zUmVuZGVyRGF0YTogS3RkRGljdGlvbmFyeTxLdGRHcmlkSXRlbVJlbmRlckRhdGE8bnVtYmVyPj47XHJcbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3JpZFNlcnZpY2U6IEt0ZEdyaWRTZXJ2aWNlLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgbGV0IG5lZWRzQ29tcGFjdExheW91dCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBuZWVkc1JlY2FsY3VsYXRlUmVuZGVyRGF0YSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBEb2VzIGZpc3QgY2hhbmdlIG5lZWQgdG8gYmUgY29tcGFjdGVkIGJ5IGRlZmF1bHQ/XHJcbiAgICAgICAgLy8gQ29tcGFjdCBsYXlvdXQgd2hlbmV2ZXIgc29tZSBkZXBlbmRlbnQgcHJvcCBjaGFuZ2VzLlxyXG4gICAgICAgIGlmIChjaGFuZ2VzLmNvbXBhY3RUeXBlIHx8IGNoYW5nZXMuY29scyB8fCBjaGFuZ2VzLmxheW91dCkge1xyXG4gICAgICAgICAgICBuZWVkc0NvbXBhY3RMYXlvdXQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2VlIG5lZWQgdG8gcmVjYWxjdWxhdGUgcmVuZGVyaW5nIGRhdGEuXHJcbiAgICAgICAgaWYgKG5lZWRzQ29tcGFjdExheW91dCB8fCBjaGFuZ2VzLnJvd0hlaWdodCkge1xyXG4gICAgICAgICAgICBuZWVkc1JlY2FsY3VsYXRlUmVuZGVyRGF0YSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPbmx5IGNvbXBhY3QgbGF5b3V0IGlmIGxpYiB1c2VyIGhhcyBwcm92aWRlZCBpdC4gTGliIHVzZXJzIHRoYXQgd2FudCB0byBzYXZlL3N0b3JlIGFsd2F5cyB0aGUgc2FtZSBsYXlvdXQgIGFzIGl0IGlzIHJlcHJlc2VudGVkIChjb21wYWN0ZWQpXHJcbiAgICAgICAgLy8gY2FuIHVzZSBLdGRDb21wYWN0R3JpZCB1dGlsaXR5IGFuZCBwcmUtY29tcGFjdCB0aGUgbGF5b3V0LiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCBiZWhhdmlvdXIgZm9yIGFsd2F5cyBoYXZpbmcgYSB0aGUgc2FtZSBsYXlvdXQgb24gdGhpcyBjb21wb25lbnRcclxuICAgICAgICAvLyBhbmQgdGhlIG9uZXMgdGhhdCB1c2VzIGl0LlxyXG4gICAgICAgIGlmIChuZWVkc0NvbXBhY3RMYXlvdXQgJiYgdGhpcy5jb21wYWN0T25Qcm9wc0NoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBhY3RMYXlvdXQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZWVkc1JlY2FsY3VsYXRlUmVuZGVyRGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVJlbmRlckRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgICAgIHRoaXMuaW5pdFN1YnNjcmlwdGlvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXNpemUoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVSZW5kZXJEYXRhKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBhY3RMYXlvdXQoKSB7XHJcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBjb21wYWN0KHRoaXMubGF5b3V0LCB0aGlzLmNvbXBhY3RUeXBlLCB0aGlzLmNvbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEl0ZW1zUmVuZGVyRGF0YSgpOiBLdGREaWN0aW9uYXJ5PEt0ZEdyaWRJdGVtUmVuZGVyRGF0YTxudW1iZXI+PiB7XHJcbiAgICAgICAgcmV0dXJuIHsuLi50aGlzLl9ncmlkSXRlbXNSZW5kZXJEYXRhfTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJdGVtUmVuZGVyRGF0YShpdGVtSWQ6IHN0cmluZyk6IEt0ZEdyaWRJdGVtUmVuZGVyRGF0YTxudW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JpZEl0ZW1zUmVuZGVyRGF0YVtpdGVtSWRdO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbGN1bGF0ZVJlbmRlckRhdGEoKSB7XHJcbiAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9ICh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdGhpcy5fZ3JpZEl0ZW1zUmVuZGVyRGF0YSA9IGxheW91dFRvUmVuZGVySXRlbXModGhpcy5jb25maWcsIGNsaWVudFJlY3Qud2lkdGgsIGNsaWVudFJlY3QuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBnZXRHcmlkSGVpZ2h0KHRoaXMubGF5b3V0LCB0aGlzLnJvd0hlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCBgJHt0aGlzLl9oZWlnaHR9cHhgKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUdyaWRJdGVtc1N0eWxlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlR3JpZEl0ZW1zU3R5bGVzKCkge1xyXG4gICAgICAgIHRoaXMuX2dyaWRJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBncmlkSXRlbVJlbmRlckRhdGE6IEt0ZEdyaWRJdGVtUmVuZGVyRGF0YTxudW1iZXI+IHwgdW5kZWZpbmVkID0gdGhpcy5fZ3JpZEl0ZW1zUmVuZGVyRGF0YVtpdGVtLmlkXTtcclxuICAgICAgICAgICAgaWYgKGdyaWRJdGVtUmVuZGVyRGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZG5cXCd0IGZpbmQgdGhlIHNwZWNpZmllZCBncmlkIGl0ZW0gZm9yIHRoZSBpZDogJHtpdGVtLmlkfWApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTdHlsZXMocGFyc2VSZW5kZXJJdGVtVG9QaXhlbHMoZ3JpZEl0ZW1SZW5kZXJEYXRhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGluaXRTdWJzY3JpcHRpb25zKCkge1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtcclxuICAgICAgICAgICAgdGhpcy5fZ3JpZEl0ZW1zLmNoYW5nZXMucGlwZShcclxuICAgICAgICAgICAgICAgIHN0YXJ0V2l0aCh0aGlzLl9ncmlkSXRlbXMpLFxyXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKChncmlkSXRlbXM6IFF1ZXJ5TGlzdDxLdGRHcmlkSXRlbUNvbXBvbmVudD4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdyaWRJdGVtcy5tYXAoKGdyaWRJdGVtKSA9PiBncmlkSXRlbS5kcmFnU3RhcnQkLnBpcGUobWFwKChldmVudCkgPT4gKHtldmVudCwgZ3JpZEl0ZW0sIHR5cGU6ICdkcmFnJ30pKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5ncmlkSXRlbXMubWFwKChncmlkSXRlbSkgPT4gZ3JpZEl0ZW0ucmVzaXplU3RhcnQkLnBpcGUobWFwKChldmVudCkgPT4gKHtldmVudCwgZ3JpZEl0ZW0sIHR5cGU6ICdyZXNpemUnfSkpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgKS5waXBlKGV4aGF1c3RNYXAoKHtldmVudCwgZ3JpZEl0ZW0sIHR5cGV9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgZHJhZyBvciByZXNpemUgc3RhcnQgZXZlbnRzLiBFbnN1cmUgdGhhdCBpcyBzdGFydCBldmVudCBpcyBpbnNpZGUgdGhlIHpvbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiAodHlwZSA9PT0gJ2RyYWcnID8gdGhpcy5kcmFnU3RhcnRlZCA6IHRoaXMucmVzaXplU3RhcnRlZCkuZW1pdChnZXREcmFnUmVzaXplRXZlbnREYXRhKGdyaWRJdGVtLCB0aGlzLmxheW91dCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb3JyZWN0IG5ld1N0YXRlRnVuYyBkZXBlbmRpbmcgb24gaWYgd2UgYXJlIGRyYWdnaW5nIG9yIHJlc2l6aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGNOZXdTdGF0ZUZ1bmMgPSB0eXBlID09PSAnZHJhZycgPyBrdGRHcmlkSXRlbURyYWdnaW5nIDoga3RkR3JpZEl0ZW1SZXNpemluZztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gZHJhZyBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtRHJhZ1NlcXVlbmNlJChncmlkSXRlbSwgZXZlbnQsIChncmlkSXRlbUlkLCBjb25maWcsIGNvbXBhY3Rpb25UeXBlLCBkcmFnZ2luZ0RhdGEpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjTmV3U3RhdGVGdW5jKGdyaWRJdGVtLCBjb25maWcsIGNvbXBhY3Rpb25UeXBlLCBkcmFnZ2luZ0RhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkucGlwZShtYXAoKGxheW91dCkgPT4gKHtsYXlvdXQsIGdyaWRJdGVtLCB0eXBlfSkpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHtsYXlvdXQsIGdyaWRJdGVtLCB0eXBlfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHJlbmRlcmluZyBkYXRhIGdpdmVuIHRoZSBuZXcgbGF5b3V0LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVSZW5kZXJEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBFbWl0IGRyYWcgb3IgcmVzaXplIGVuZCBldmVudHMuXHJcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gJ2RyYWcnID8gdGhpcy5kcmFnRW5kZWQgOiB0aGlzLnJlc2l6ZUVuZGVkKS5lbWl0KGdldERyYWdSZXNpemVFdmVudERhdGEoZ3JpZEl0ZW0sIGxheW91dCkpO1xyXG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHRoYXQgdGhlIGxheW91dCBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRVcGRhdGVkLmVtaXQobGF5b3V0KTtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm0gYSBnZW5lcmFsIGdyaWQgZHJhZyBhY3Rpb24sIGZyb20gc3RhcnQgdG8gZW5kLiBBIGdlbmVyYWwgZ3JpZCBkcmFnIGFjdGlvbiBiYXNpY2FsbHkgaW5jbHVkZXMgY3JlYXRpbmcgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQgYW5kIGFkZGluZ1xyXG4gICAgICogc29tZSBjbGFzcyBhbmltYXRpb25zLiBjYWxjTmV3U3RhdGVGdW5jIG5lZWRzIHRvIGJlIHByb3ZpZGVkIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgbmV3IHN0YXRlIG9mIHRoZSBsYXlvdXQuXHJcbiAgICAgKiBAcGFyYW0gZ3JpZEl0ZW0gdGhhdCBpcyBiZWVuIGRyYWdnZWRcclxuICAgICAqIEBwYXJhbSBwb2ludGVyRG93bkV2ZW50IGV2ZW50IChtb3VzZWRvd24gb3IgdG91Y2hkb3duKSB3aGVyZSB0aGUgdXNlciBpbml0aWF0ZWQgdGhlIGRyYWdcclxuICAgICAqIEBwYXJhbSBjYWxjTmV3U3RhdGVGdW5jIGZ1bmN0aW9uIHRoYXQgcmV0dXJuIHRoZSBuZXcgbGF5b3V0IHN0YXRlIGFuZCB0aGUgZHJhZyBlbGVtZW50IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGVyZm9ybURyYWdTZXF1ZW5jZSQoZ3JpZEl0ZW06IEt0ZEdyaWRJdGVtQ29tcG9uZW50LCBwb2ludGVyRG93bkV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY05ld1N0YXRlRnVuYzogKGdyaWRJdGVtOiBLdGRHcmlkSXRlbUNvbXBvbmVudCwgY29uZmlnOiBLdGRHcmlkQ2ZnLCBjb21wYWN0aW9uVHlwZTogQ29tcGFjdFR5cGUsIGRyYWdnaW5nRGF0YTogS3RkRHJhZ2dpbmdEYXRhKSA9PiB7IGxheW91dDogS3RkR3JpZExheW91dEl0ZW1bXTsgZHJhZ2dlZEl0ZW1Qb3M6IEt0ZEdyaWRJdGVtUmVjdCB9KTogT2JzZXJ2YWJsZTxLdGRHcmlkTGF5b3V0PiB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxLdGRHcmlkTGF5b3V0Pigob2JzZXJ2ZXI6IE9ic2VydmVyPEt0ZEdyaWRMYXlvdXQ+KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGdyaWQgKHBhcmVudCkgYW5kIGdyaWRJdGVtIChkcmFnZ2VkRWxlbSkgY2xpZW50IHJlY3RzLlxyXG4gICAgICAgICAgICBjb25zdCBncmlkRWxlbUNsaWVudFJlY3Q6IENsaWVudFJlY3QgPSBnZXRNdXRhYmxlQ2xpZW50UmVjdCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRyYWdFbGVtQ2xpZW50UmVjdDogQ2xpZW50UmVjdCA9IGdldE11dGFibGVDbGllbnRSZWN0KGdyaWRJdGVtLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlUGFyZW50ID0gdHlwZW9mIHRoaXMuc2Nyb2xsYWJsZVBhcmVudCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnNjcm9sbGFibGVQYXJlbnQpIDogdGhpcy5zY3JvbGxhYmxlUGFyZW50O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhncmlkSXRlbS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICduby10cmFuc2l0aW9ucycpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGdyaWRJdGVtLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2t0ZC1ncmlkLWl0ZW0tZHJhZ2dpbmcnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBlbGVtZW50LiBUaGlzIGVsZW1lbnQgd291bGQgcmVwcmVzZW50IHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgZHJhZ2dlZC9yZXNpemVkIGVsZW1lbnQgd291bGQgYmUgaWYgdGhlIGFjdGlvbiBlbmRzXHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRWxlbWVudDogSFRNTERpdkVsZW1lbnQgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtkcmFnRWxlbUNsaWVudFJlY3Qud2lkdGh9cHhgO1xyXG4gICAgICAgICAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7ZHJhZ0VsZW1DbGllbnRSZWN0LmhlaWdodH1weGA7XHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke2RyYWdFbGVtQ2xpZW50UmVjdC5sZWZ0IC0gZ3JpZEVsZW1DbGllbnRSZWN0LmxlZnR9cHgpIHRyYW5zbGF0ZVkoJHtkcmFnRWxlbUNsaWVudFJlY3QudG9wIC0gZ3JpZEVsZW1DbGllbnRSZWN0LnRvcH1weClgO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhwbGFjZWhvbGRlckVsZW1lbnQsICdrdGQtZ3JpZC1pdGVtLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHBsYWNlaG9sZGVyRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV3TGF5b3V0OiBLdGRHcmlkTGF5b3V0SXRlbVtdO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyAoZW5oYW5jZW1lbnQpOiBjb25zaWRlciBtb3ZlIHRoaXMgJ3NpZGUgZWZmZWN0JyBvYnNlcnZhYmxlIGluc2lkZSB0aGUgbWFpbiBkcmFnIGxvb3AuXHJcbiAgICAgICAgICAgIC8vICAtIFByb3MgYXJlIHRoYXQgd2Ugd291bGQgbm90IHJlcGVhdCBzdWJzY3JpcHRpb25zIGFuZCB0YWtlVW50aWwgd291bGQgc2h1dCBkb3duIG9ic2VydmFibGVzIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICAgICAgICAgIC8vICAtIENvbnMgYXJlIHRoYXQgbW92aW5nIHRoaXMgZnVuY3Rpb25hbGl0eSBhcyBhIHNpZGUgZWZmZWN0IGluc2lkZSB0aGUgbWFpbiBkcmFnIGxvb3Agd291bGQgYmUgY29uZnVzaW5nLlxyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxTdWJzY3JpcHRpb24gPSB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxyXG4gICAgICAgICAgICAgICAgKCFzY3JvbGxhYmxlUGFyZW50ID8gTkVWRVIgOiB0aGlzLmdyaWRTZXJ2aWNlLm1vdXNlT3JUb3VjaE1vdmUkKGRvY3VtZW50KS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcCgoZXZlbnQpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJYOiBrdGRQb2ludGVyQ2xpZW50WChldmVudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJZOiBrdGRQb2ludGVyQ2xpZW50WShldmVudClcclxuICAgICAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICAgICAga3RkU2Nyb2xsSWZOZWFyRWxlbWVudENsaWVudFJlY3QkKHNjcm9sbGFibGVQYXJlbnQsIHtzY3JvbGxTdGVwOiB0aGlzLnNjcm9sbFNwZWVkfSlcclxuICAgICAgICAgICAgICAgICkpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKGt0ZE1vdXNlT3JUb3VjaEVuZChkb2N1bWVudCkpXHJcbiAgICAgICAgICAgICAgICApLnN1YnNjcmliZSgpKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYWluIHN1YnNjcmlwdGlvbiwgaXQgbGlzdGVucyBmb3IgJ3BvaW50ZXIgbW92ZScgYW5kICdzY3JvbGwnIGV2ZW50cyBhbmQgcmVjYWxjdWxhdGVzIHRoZSBsYXlvdXQgb24gZWFjaCBlbWlzc2lvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cclxuICAgICAgICAgICAgICAgIG1lcmdlKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVMYXRlc3QoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRTZXJ2aWNlLm1vdXNlT3JUb3VjaE1vdmUkKGRvY3VtZW50KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKCFzY3JvbGxhYmxlUGFyZW50ID8gW29mKHt0b3A6IDAsIGxlZnQ6IDB9KV0gOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrdGRHZXRTY3JvbGxUb3RhbFJlbGF0aXZlRGlmZmVyZW5jZSQoc2Nyb2xsYWJsZVBhcmVudCkucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFdpdGgoe3RvcDogMCwgbGVmdDogMH0pIC8vIEZvcmNlIGZpcnN0IGVtaXNzaW9uIHRvIGFsbG93IENvbWJpbmVMYXRlc3QgdG8gZW1pdCBldmVuIG5vIHNjcm9sbCBldmVudCBoYXMgb2NjdXJyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChrdGRNb3VzZU9yVG91Y2hFbmQoZG9jdW1lbnQpKSxcclxuICAgICAgICAgICAgICAgICkuc3Vic2NyaWJlKChbcG9pbnRlckRyYWdFdmVudCwgc2Nyb2xsRGlmZmVyZW5jZV06IFtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCwgeyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyIH1dKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJEcmFnRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXQgdGhlIG5ldyBsYXlvdXQgdG8gYmUgdGhlIGxheW91dCBpbiB3aGljaCB0aGUgY2FsY05ld1N0YXRlRnVuYyB3b3VsZCBiZSBleGVjdXRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICogTk9URTogdXNpbmcgdGhlIG11dGF0ZWQgbGF5b3V0IGlzIHRoZSB3YXkgdG8gZ28gYnkgJ3JlYWN0LWdyaWQtbGF5b3V0JyB1dGlscy4gSWYgd2UgZG9uJ3QgdXNlIHRoZSBwcmV2aW91cyBsYXlvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNvbWUgdXRpbGl0aWVzIGZyb20gJ3JlYWN0LWdyaWQtbGF5b3V0JyB3b3VsZCBub3Qgd29yayBhcyBleHBlY3RlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMYXlvdXQ6IEt0ZEdyaWRMYXlvdXQgPSBuZXdMYXlvdXQgfHwgdGhpcy5sYXlvdXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7bGF5b3V0LCBkcmFnZ2VkSXRlbVBvc30gPSBjYWxjTmV3U3RhdGVGdW5jKGdyaWRJdGVtLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IGN1cnJlbnRMYXlvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQ6IHRoaXMucm93SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sczogdGhpcy5jb2xzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudENvbGxpc2lvbjogdGhpcy5wcmV2ZW50Q29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuY29tcGFjdFR5cGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJEb3duRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyRHJhZ0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZEVsZW1DbGllbnRSZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0VsZW1DbGllbnRSZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlmZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGF5b3V0ID0gbGF5b3V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gZ2V0R3JpZEhlaWdodChuZXdMYXlvdXQsIHRoaXMucm93SGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyaWRJdGVtc1JlbmRlckRhdGEgPSBsYXlvdXRUb1JlbmRlckl0ZW1zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHM6IHRoaXMuY29scyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0hlaWdodDogdGhpcy5yb3dIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRDb2xsaXNpb246IHRoaXMucHJldmVudENvbGxpc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZ3JpZEVsZW1DbGllbnRSZWN0LndpZHRoLCBncmlkRWxlbUNsaWVudFJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyU3R5bGVzID0gcGFyc2VSZW5kZXJJdGVtVG9QaXhlbHModGhpcy5fZ3JpZEl0ZW1zUmVuZGVyRGF0YVtncmlkSXRlbS5pZF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHV0IHRoZSByZWFsIGZpbmFsIHBvc2l0aW9uIHRvIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS53aWR0aCA9IHBsYWNlaG9sZGVyU3R5bGVzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gcGxhY2Vob2xkZXJTdHlsZXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtwbGFjZWhvbGRlclN0eWxlcy5sZWZ0fSkgdHJhbnNsYXRlWSgke3BsYWNlaG9sZGVyU3R5bGVzLnRvcH0pYDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGlmeSB0aGUgcG9zaXRpb24gb2YgdGhlIGRyYWdnZWQgaXRlbSB0byBiZSB0aGUgb25jZSB3ZSB3YW50IChmb3IgZXhhbXBsZSB0aGUgbW91c2UgcG9zaXRpb24gb3Igd2hhdGV2ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyaWRJdGVtc1JlbmRlckRhdGFbZ3JpZEl0ZW0uaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZHJhZ2dlZEl0ZW1Qb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5fZ3JpZEl0ZW1zUmVuZGVyRGF0YVtncmlkSXRlbS5pZF0uaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAoZXJyb3IpID0+IG9ic2VydmVyLmVycm9yKGVycm9yKSxcclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZHJhZyBjbGFzc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGdyaWRJdGVtLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ25vLXRyYW5zaXRpb25zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGdyaWRJdGVtLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2t0ZC1ncmlkLWl0ZW0tZHJhZ2dpbmcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcGxhY2Vob2xkZXIgZWxlbWVudCBmcm9tIHRoZSBkb21cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IElmIHdlIGRvbid0IHB1dCB0aGUgcmVtb3ZlQ2hpbGQgaW5zaWRlIHRoZSB6b25lIGl0IHdvdWxkIG5vdCB3b3JrLi4uIFRoaXMgbWF5IGJlIGEgYnVnIGZyb20gYW5ndWxhciBvciBtYXliZSBpcyB0aGUgaW50ZW5kZWQgYmVoYXZpb3VyLCBhbHRob3VnaCBzdHJhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgc2hvdWxkIHdvcmsgc2luY2UgQUZBSUsgdGhpcyBhY3Rpb24gc2hvdWxkIG5vdCBiZSBkb25lIGluIGEgQ0QgY3ljbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBwbGFjZWhvbGRlckVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdMYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBuZXdMYXlvdXQgc2hvdWxkIGFscmVhZHkgYmUgcHJ1bmVkLiBJZiBub3QsIGl0IHNob3VsZCBoYXZlIHR5cGUgTGF5b3V0LCBub3QgS3RkR3JpZExheW91dCBhcyBpdCBpcyBub3cuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJ1bmUgcmVhY3QtZ3JpZC1sYXlvdXQgY29tcGFjdCBleHRyYSBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3TGF5b3V0Lm1hcChpdGVtID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGl0ZW0ueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogaXRlbS53LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBpdGVtLmgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblc6IGl0ZW0ubWluVyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluSDogaXRlbS5taW5ILFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXOiBpdGVtLm1heFcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEg6IGl0ZW0ubWF4SCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgYXMgS3RkR3JpZExheW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgd2UgcmVhbGx5IHRvIGVtaXQgaWYgdGhlcmUgaXMgbm8gbGF5b3V0IGNoYW5nZSBidXQgZHJhZyBzdGFydGVkIGFuZCBlbmRlZD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHRoaXMubGF5b3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9jb2xzOiBOdW1iZXJJbnB1dDtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3Jvd0hlaWdodDogTnVtYmVySW5wdXQ7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zY3JvbGxTcGVlZDogTnVtYmVySW5wdXQ7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9jb21wYWN0T25Qcm9wc0NoYW5nZTogQm9vbGVhbklucHV0O1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcHJldmVudENvbGxpc2lvbjogQm9vbGVhbklucHV0O1xyXG59XHJcblxyXG4iLCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbiJdfQ==